Changes:	- original version; created by h2xs 1.22 with options
Changes:		-AXc -n Audio::Ecasound::Flow
Flow.bak:	@widget_t,  # take-related widgets, index by $take
Flow.bak:	%widget_c,  # chain-related widgets, index by $n
Flow.bak:	%widget_e,  # effect-related widgets, index by $id
Flow.bak:	@widget_o,  # session-level oid-related widgets, array
Flow.bak:	%widget_o,  # session-level oid-related widgets, name as key
Flow.bak:# for sample-rate dependent LADSPA effect parameters, ideally 
Flow.bak:# should change with per-project sample rates in parameters.pl
Flow.bak:my $ladspa_sample_rate = 44100; # for sample-rate dependent effect
Flow.bak:$unit  = 1; # fast-forward multiplier default;
Flow.bak:	my $self = $$class->new;
Flow.bak:	-d $wav_dir or croak qq("$wav_dir" not a directory\n);
Flow.bak:	$::OUT = $term->OUT || \*STDOUT;
Flow.bak:		($user_input) = $term->readline($prompt) ;
Flow.bak:		$term->addhistory($user_input) ;
Flow.bak:			$parser->command($predicate) or print ("Returned false\n");
Flow.bak:			$parser->command($user_input) or print ("Parse failed\n");
Flow.bak:	my $result = $e->eci($command);
Flow.bak:	my $errmsg = $e->errmsg();
Flow.bak:	$e->errmsg('');
Flow.bak:	$config = YAML::Tiny->new;
Flow.bak:	#$yaml = io($yamlfile)->all if -f $yamlfile;
Flow.bak:	$config = YAML::Tiny->read_string($yaml);
Flow.bak:	ref $config->[0] or croak "not ref!";
Flow.bak:	*cfg = \%{$config->[0]}; # alias
Flow.bak:	#print $config->write_string();
Flow.bak:	#print $config->write_string();
Flow.bak:	$debug and print $config->write_string; 
Flow.bak:	my $val = $parent->{$key};
Flow.bak:		or map{$parent->{$key} =~ s/$_/$subst{$_}/} keys %subst;
Flow.bak:	$debug and print "\$session: $session name: $hash->{name} create: $hash->{create}\n";
Flow.bak:	$session_name = $hash->{name} ? $hash->{name} : $session;
Flow.bak:	$hash->{create} and 
Flow.bak:	carp ("missing session file $sf\n") unless -f $sf;
Flow.bak:	$gui and $session_label->configure(
Flow.bak:		-text => uc $session_name, 
Flow.bak:		-background => 'lightyellow',
Flow.bak:	                        # indexed by {$id}->[$param_no]
Flow.bak:	map{ $_->destroy } map{ $_->children } $effect_frame;
Flow.bak:	my @children = $take_frame->children;
Flow.bak:	map{ $_->destroy  } @children[1..$#children];
Flow.bak:	@children = $track_frame->children;
Flow.bak:	map{ $_->destroy  } @children[11..$#children]; # fragile
Flow.bak:	-d $dir 
Flow.bak:	$state_t{$t}->{rw} = REC;
Flow.bak:	#&set_active_version($i) if ! defined $state_c{$i}->{active};
Flow.bak:	$state_c{$i}->{ops} = [] if ! defined $state_c{$i}->{ops};
Flow.bak:	$state_c{$i}->{rw} = REC if ! defined $state_c{$i}->{rw};
Flow.bak:	# return if $opts{m} or ! -e &join_path(&session_dir,$statestore);
Flow.bak:	$state_t{$t}->{rw} = MUTE; 
Flow.bak:	$state_t{$t}->{rw} = MON;
Flow.bak:	$state_c{$i}->{rw} = REC;
Flow.bak:	$state_c{$i}->{ch_m} = $ch_m;
Flow.bak:	$state_c{$i}->{ch_r} = $ch_r;
Flow.bak:	$state_c{$i}->{file} = $name;
Flow.bak:	print "getting versions for chain $n, state_c{$n}->{file}\n";
Flow.bak:			$state_c{$n}->{file},
Flow.bak:		delete $state_c{$n}->{targets};
Flow.bak:		$state_c{$n}->{targets} = { %versions };
Flow.bak:		 $state_c{$n}->{versions} = [ sort { $a <=> $b } 
Flow.bak:		 	keys %{$state_c{$n}->{targets}} ];
Flow.bak:		$debug and print join " ", "versions: ",@ {$state_c{$n}->{versions}} , "\n\n";
Flow.bak:		my $this_last = $state_c{$n}->{versions}->[-1];
Flow.bak:		#$state_c{$n}->{active} = $state_c{$n}->{versions}->[-1]
Flow.bak:		#	unless grep{ $state_c{$n}->{active} == $_ }
Flow.bak:		#		@{$state_c{$n}->{versions}};
Flow.bak:	my $cmd = qq(find $a  -name '*.wav' -size 44c);
Flow.bak:	#map {system qq(ls -l $_ ) } @wavs; exit;
Flow.bak:	map { print ($_, "\n") if -s == 44 } @wavs; 
Flow.bak:	map { unlink $_ if -s == 44 } @wavs; 
Flow.bak:					$state_t{$t}->{rw} = REC;
Flow.bak:			$t--;
Flow.bak:			my @candidate = $take_frame->children;
Flow.bak:			$candidate[-1]->destroy;
Flow.bak:	$state_t{$t}->{rw} = $status; 
Flow.bak:	$mw = MainWindow->new; 
Flow.bak:	$mw->title("Tk Ecmd"); 
Flow.bak:	$ew = $mw->Toplevel;
Flow.bak:	$ew->title("Effect Window");
Flow.bak:	$ew->withdraw;
Flow.bak:	$canvas = $ew->Scrolled('Canvas')->pack;
Flow.bak:	$canvas->configure(
Flow.bak:		-width => 900,
Flow.bak:		-height => 600,	
Flow.bak:# 		-width => 1000,
Flow.bak:# 		-height => 4000,	
Flow.bak:	$effect_frame = $canvas->Frame;
Flow.bak:	my $id = $canvas->createWindow(30,30, -window => $effect_frame,
Flow.bak:											-anchor => 'nw');
Flow.bak:	$session_label = $mw->Label->pack(-fill => 'both');
Flow.bak:	$old_bg = $session_label->cget('-background');
Flow.bak:	$time_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$transport_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$oid_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$clock_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$track_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$take_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$take_label = $take_frame->Menubutton(-text => "Group",-tearoff => 0,)->pack(-side => 'left');
Flow.bak:	$add_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$perl_eval_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$iam_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:	$load_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.bak:#	my $blank = $mw->Label->pack(-side => 'left');
Flow.bak:	$sn_label = $load_frame->Label(-text => "Enter session name:")->pack(-side => 'left');
Flow.bak:	$sn_text = $load_frame->Entry(-textvariable => \$session, -width => 45)->pack(-side => 'left');
Flow.bak:	$sn_load = $load_frame->Button->pack(-side => 'left');;
Flow.bak:#	$sn_load_nostate = $load_frame->Button->pack(-side => 'left');;
Flow.bak:	$sn_new = $load_frame->Button->pack(-side => 'left');;
Flow.bak:	$sn_quit = $load_frame->Button->pack(-side => 'left');
Flow.bak:	$build_track_label = $add_frame->Label(-text => "Track")->pack(-side => 'left');
Flow.bak:	$build_track_text = $add_frame->Entry(-textvariable => \$track_name, -width => 12)->pack(-side => 'left');
Flow.bak:	$build_track_rec_label = $add_frame->Label(-text => "REC")->pack(-side => 'left');
Flow.bak:	$build_track_rec_text = $add_frame->Entry(-textvariable => \$ch_r, -width => 2)->pack(-side => 'left');
Flow.bak:	$build_track_mon_label = $add_frame->Label(-text => "MON")->pack(-side => 'left');
Flow.bak:	$build_track_mon_text = $add_frame->Entry(-textvariable => \$ch_m, -width => 2)->pack(-side => 'left');
Flow.bak:	$build_track_add = $add_frame->Button->pack(-side => 'left');;
Flow.bak:	$sn_load->configure(
Flow.bak:		-text => 'Load',
Flow.bak:		-command => \&load_session,
Flow.bak:	$sn_new->configure( 
Flow.bak:		-text => 'New',
Flow.bak:		-command => sub { &load_session({create => 1}) },
Flow.bak:	$sn_quit->configure(-text => "Quit",
Flow.bak:		 -command => sub { 
Flow.bak:	$build_track_add->configure( 
Flow.bak:			-text => 'Add',
Flow.bak:			-command => sub { &add_track($track_name) }
Flow.bak:	$build_new_take->configure( 
Flow.bak:			-text => 'New Group',
Flow.bak:			-command =>
Flow.bak:	map{ push @widgets, $track_frame->Label(-text => $_)  } @labels;
Flow.bak:	$widgets[0]->grid(@widgets[1..$#widgets]);
Flow.bak:	$iam_label = $iam_frame->Label(-text => "IAM Command")
Flow.bak:		->pack(-side => 'left');;
Flow.bak:	$iam_text = $iam_frame->Entry( 
Flow.bak:		-textvariable => \$iam, -width => 65)
Flow.bak:		->pack(-side => 'left');;
Flow.bak:	$iam_execute = $iam_frame->Button(
Flow.bak:			-text => 'Execute',
Flow.bak:			-command => sub { print &eval_iam($iam), "\n" }
Flow.bak:		)->pack(-side => 'left');;
Flow.bak:	my $perl_eval_label = $perl_eval_frame->Label(
Flow.bak:		-text => "Perl Command")
Flow.bak:		->pack(-side => 'left');;
Flow.bak:	my $perl_eval_text = $perl_eval_frame->Entry(
Flow.bak:		-textvariable => \$perl_eval, -width => 65)
Flow.bak:		->pack(-side => 'left');;
Flow.bak:	my $perl_eval_execute = $perl_eval_frame->Button(
Flow.bak:			-text => 'Execute',
Flow.bak:			-command => sub { eval $perl_eval  }
Flow.bak:		)->pack(-side => 'left');;
Flow.bak:	$transport_label = $transport_frame->Label(
Flow.bak:		-text => 'TRANSPORT',
Flow.bak:		-width => 12,
Flow.bak:		)->pack(-side => 'left');;
Flow.bak:	$transport_setup_and_connect  = $transport_frame->Button->pack(-side => 'left');;
Flow.bak:	$transport_start = $transport_frame->Button->pack(-side => 'left');
Flow.bak:	$transport_stop = $transport_frame->Button->pack(-side => 'left');
Flow.bak:	$transport_setup = $transport_frame->Button->pack(-side => 'left');;
Flow.bak:	$transport_connect = $transport_frame->Button->pack(-side => 'left');;
Flow.bak:	$transport_disconnect = $transport_frame->Button->pack(-side => 'left');;
Flow.bak:	$transport_new = $transport_frame->Button->pack(-side => 'left');;
Flow.bak:	$transport_stop->configure(-text => "Stop",
Flow.bak:	-command => sub { 
Flow.bak:	$transport_start->configure(
Flow.bak:		-text => "Start!",
Flow.bak:		-command => sub { 
Flow.bak:			$session_label->configure(-background => 'lightpink') 
Flow.bak:			$session_label->configure(-background => 'lightgreen') 
Flow.bak:	$transport_setup_and_connect->configure(
Flow.bak:			-text => 'Generate and connect',
Flow.bak:			-command => sub {&setup_transport; &connect_transport}
Flow.bak:	$transport_setup->configure(
Flow.bak:			-text => 'Generate chain setup',
Flow.bak:			-command => \&setup_transport,
Flow.bak:	$transport_connect->configure(
Flow.bak:			-text => 'Connect chain setup',
Flow.bak:			-command => \&connect_transport,
Flow.bak:	$transport_disconnect->configure(
Flow.bak:			-text => 'Disconnect setup',
Flow.bak:			-command => sub { &disconnect_transport },
Flow.bak:	$transport_new->configure(
Flow.bak:			-text => 'New Engine',
Flow.bak:			-command => \&new_engine,
Flow.bak:	my $time_label = $clock_frame->Label(
Flow.bak:		-text => 'TIME', 
Flow.bak:		-width => 12);
Flow.bak:	$clock = $clock_frame->Label(
Flow.bak:		-text => '0:00', 
Flow.bak:		-width => 8,
Flow.bak:		-background => 'orange',
Flow.bak:	my $length_label = $clock_frame->Label(
Flow.bak:		-text => 'LENGTH',
Flow.bak:		-width => 10,
Flow.bak:	$setup_length = $clock_frame->Label(
Flow.bak:	#	-width => 8,
Flow.bak:		$w->pack(-side => 'left');	
Flow.bak:	my $mark_frame = $time_frame->Frame->pack(
Flow.bak:		-side => 'bottom', 
Flow.bak:		-fill => 'both');
Flow.bak:	my $fast_frame = $time_frame->Frame->pack(
Flow.bak:		-side => 'bottom', 
Flow.bak:		-fill => 'both');
Flow.bak:	my $jump_label = $fast_frame->Label(-text => q(JUMP), -width => 12);
Flow.bak:	my $mark_label = $mark_frame->Label(-text => q(MARK), -width => 12);
Flow.bak:	my @minuses = map{ - $_ } reverse @pluses;
Flow.bak:	my @fw = map{ my $d = $_; $fast_frame->Button(
Flow.bak:			-text => $d,
Flow.bak:			-command => sub { &jump($d) },
Flow.bak:	my @rew = map{ my $d = $_; $fast_frame->Button(
Flow.bak:			-text => $d,
Flow.bak:			-command => sub { &jump($d) },
Flow.bak:	my $beg = $fast_frame->Button(
Flow.bak:			-text => 'Beg',
Flow.bak:			-command => \&to_start,
Flow.bak:	my $end = $fast_frame->Button(
Flow.bak:			-text => 'End',
Flow.bak:			-command => \&to_end,
Flow.bak:	$time_step = $fast_frame->Button( 
Flow.bak:			-text => 'Sec',
Flow.bak:			$w->pack(-side => 'left')
Flow.bak:	$time_step->configure (-command => \&toggle_unit);
Flow.bak:	push @label_and_arm, $mark_frame->Button(
Flow.bak:		-text => 'Set',
Flow.bak:		-command => sub { &arm_mark },
Flow.bak:	map { push @time_marks, $mark_frame->Button( 
Flow.bak:		-text => $_,
Flow.bak:		-command => sub { &mark(eval $_)},
Flow.bak:		-background => $marks[$_] ? $old_bg : 'lightblue',
Flow.bak:	# map { $time_marks[$_]->configure( -command => sub { # &mark($_)} ) } @m[1..$#m];
Flow.bak:		$time_marks[$m]->configure( -command => sub { &mark($m)} )
Flow.bak:	#$time_marks[3]->configure( -background => 'orange' );
Flow.bak:#	 map { $time_marks[$_]->configure(-background => 'orange')} @m;
Flow.bak: 		$w->pack(-side => 'left')
Flow.bak:#	$time_marks[0]->grid(@time_marks[@m]);
Flow.bak:	my $outputs = $oid_frame->Label(-text => 'OUTPUTS', -width => 12);
Flow.bak:		# print "gui oid name: $oid->{name} status: $oid_status{$oid->{name}}\n";
Flow.bak:		next if $oid->{name} =~ m/setup/;
Flow.bak:		push @oid_name, $oid->{name};
Flow.bak:		my $oid_button = $oid_frame->Button( 
Flow.bak:			-text => ucfirst $oid->{name},
Flow.bak:			-background => 
Flow.bak:				$oid_status{$oid->{name}} ?  'AntiqueWhite' : $old_bg,
Flow.bak:			-activebackground => 
Flow.bak:				$oid_status{$oid->{name}} ? 'AntiqueWhite' : $old_bg
Flow.bak:		$widget_o{$oid->{name}} = $oid_button;
Flow.bak:		$widget_o[$i]->configure(
Flow.bak:			-command => sub { 
Flow.bak:				$widget_o[$i]->configure( -background => 
Flow.bak:			-activebackground => 
Flow.bak:	my $toggle_jack = $oid_frame->Button;
Flow.bak:	$toggle_jack->configure(
Flow.bak:		-text => q(Jack ON/OFF),
Flow.bak:		-command => sub {
Flow.bak:			my $color = $toggle_jack->cget( -background );
Flow.bak:	map { $_ -> pack(-side => 'left') } ($outputs, @widget_o);
Flow.bak:	$button->configure(-background => $color,
Flow.bak:						-activebackground => $color);
Flow.bak:	$setup_length->configure(-background =>
Flow.bak:	$setup_length->after(10000, 
Flow.bak:		sub{ $setup_length->configure(-background => $old_bg) }
Flow.bak:		my $name = $take_frame->Menubutton(
Flow.bak:				-text => ucfirst $tname,
Flow.bak:				-tearoff =>0,
Flow.bak:			)->pack(-side => 'left');
Flow.bak:		$name->AddItems([
Flow.bak:			-background => $old_bg,
Flow.bak:			-command => sub { 
Flow.bak:		$name->AddItems([
Flow.bak:			-background => $old_bg,
Flow.bak:			-command => sub {
Flow.bak:		$name->AddItems([
Flow.bak:			-background => $old_bg,
Flow.bak:			-command => sub {
Flow.bak:#	( map{ $_->destroy } @global_version_buttons ) if @global_version_buttons; 
Flow.bak:    my @children = $widget_t[1]->children;
Flow.bak:		$_->cget(-value) and $_->destroy;
Flow.bak:		next unless grep{  grep{ $v == $_ } @{ $state_c{$_}->{versions} } }
Flow.bak:			$widget_t[1]->radiobutton(
Flow.bak:				-label => ($v ? $v : ''),
Flow.bak:				-variable => \$monitor_version,
Flow.bak:				-value => $v,
Flow.bak:				-command => sub { 
Flow.bak:					$state_t{2}->{rw} = MON; ### HARDCODED SECOND TAKE; MIX
Flow.bak:	my $stub = $state_c{$n}->{active};
Flow.bak:	$name = $track_frame->Label(
Flow.bak:			-text => $state_c{$n}->{file},
Flow.bak:			-justify => 'left');
Flow.bak:	$version = $track_frame->Menubutton( 
Flow.bak:					-text => $stub,
Flow.bak:					-tearoff => 0);
Flow.bak:	for my $v (undef, @{$state_c{$n}->{versions}}) {
Flow.bak:					$version->radiobutton(
Flow.bak:						-label => ($v ? $v: ''),
Flow.bak:						-variable => \$state_c{$n}->{active},
Flow.bak:						-value => $v,
Flow.bak:						-command => 
Flow.bak:		sub { $version->configure(-text=> &selected_version($n) ) 
Flow.bak:	$ch_r = $track_frame->Menubutton(
Flow.bak:					-textvariable => \$state_c{$n}->{ch_r},
Flow.bak:					-tearoff => 0,
Flow.bak:					$ch_r->radiobutton(
Flow.bak:						-label => $v,
Flow.bak:						-variable => \$state_c{$n}->{ch_r},
Flow.bak:						-value => $v,
Flow.bak:						-command => sub { 
Flow.bak:							$state_c{$n}->{rw} = REC;
Flow.bak:	$ch_m = $track_frame->Menubutton(
Flow.bak:					-textvariable => \$state_c{$n}->{ch_m},
Flow.bak:					-tearoff => 0,
Flow.bak:					$ch_m->radiobutton(
Flow.bak:						-label => $v,
Flow.bak:						-variable => \$state_c{$n}->{ch_m},
Flow.bak:						-value => $v,
Flow.bak:						-command => sub { 
Flow.bak:							$state_c{$n}->{rw} = MON;
Flow.bak:	$rw = $track_frame->Menubutton(
Flow.bak:		-text => $state_c{$n}->{rw},
Flow.bak:		-tearoff => 0,
Flow.bak:				-foreground => 'red',
Flow.bak:				-command  => sub { 
Flow.bak:					$state_c{$n}->{rw} = REC;
Flow.bak:				-command  => sub { 
Flow.bak:					$state_c{$n}->{rw} = MON;
Flow.bak:				-command  => sub { 
Flow.bak:					$state_c{$n}->{rw} = MUTE;
Flow.bak:	map{$rw->AddItems($_) unless $n == 1} @items; # MIX CONDITIONAL
Flow.bak:	$state_c{$n}->{rw} = MON if $n == 1;          # MIX
Flow.bak:	$mute = $track_frame->Button;
Flow.bak:	$mute->configure( -command => sub { &toggle_muting($mute, $n) });
Flow.bak:	$mute = $track_frame->Button(
Flow.bak:	  		-command => sub { 
Flow.bak:				if ($copp{$vol_id}->[0]) {  # non-zero volume
Flow.bak:					$old_vol{$n}=$copp{$vol_id}->[0];
Flow.bak:					$copp{$vol_id}->[0] = 0;
Flow.bak:					$mute->configure(-background => 'brown');
Flow.bak:					$mute->configure(-activebackground => 'brown');
Flow.bak:					$copp{$vol_id}->[0] = $old_vol{$n};
Flow.bak:					$mute->configure(-background => $old_bg);
Flow.bak:					$mute->configure(-activebackground => $old_bg);
Flow.bak:	$solo = $track_frame->Button;
Flow.bak:	$solo->configure( -command => sub {
Flow.bak:		return if ! grep{/$session_name/} &eval_iam(q(cs-connected));
Flow.bak:			$solo->configure(-foreground => $old_bg );
Flow.bak:			$solo->configure(-activeforeground => $old_bg );
Flow.bak:			$solo->configure(-foreground => q(yellow) );
Flow.bak:			$solo->configure(-activeforeground => q(yellow) );
Flow.bak:	$unity = $track_frame->Button(
Flow.bak:	  		-command => sub { 
Flow.bak:				$copp{$vol_id}->[0] = 100;
Flow.bak:	$center = $track_frame->Button(
Flow.bak:	  	-command => sub { 
Flow.bak:			$copp{$pan_id}->[0] = 50;
Flow.bak:	my $effects = $effect_frame->Frame->pack(-fill => 'both');;
Flow.bak:	# effects, held by widget_c->n->effects is the frame for
Flow.bak:	my $parents = ${ $widget_c{$n}->{effects} }->Frame->pack(-fill => 'x');
Flow.bak:	my $children = ${ $widget_c{$n}->{effects} }->Frame->pack(-fill => 'x');
Flow.bak:	$widget_c{$n}->{parents} = $parents;   # parents belong here
Flow.bak:	$widget_c{$n}->{children} = $children; # children go here
Flow.bak:	$parents->Label(-text => (uc $stub) )->pack(-side => 'left');
Flow.bak:					 $e_bound{ladspa}{b}-1, 
Flow.bak:					 $e_bound{ladspa}{c}-1, 
Flow.bak:					 $e_bound{ladspa}{d}-1, 
Flow.bak:	$name->grid($version, $rw, $ch_r, $ch_m, $vol, $mute, $unity, $pan, $center, @add_effect);
Flow.bak:				cop_id => $state_c{$n}->{vol}, # often undefined
Flow.bak:	$state_c{$n}->{vol} = $vol_id;  # save the id for next time
Flow.bak:				cop_id => $state_c{$n}->{pan}, # often undefined
Flow.bak:	$state_c{$n}->{pan} = $vol_id;  # save the id for next time
Flow.bak:		print "adding effect: $effects[$j]->{name}\n";
Flow.bak:			[ 'command' => "$effects[$j]->{count} $effects[$j]->{name}" ,
Flow.bak:				-command  => sub { 
Flow.bak:					 &add_effect( {chain => $n, type => $effects[$j]->{code} } ); 
Flow.bak:					$ew->deiconify; # display effects window
Flow.bak:	$widget = $track_frame->Menubutton(
Flow.bak:		-text => $label,
Flow.bak:		-tearoff =>0,
Flow.bak:		-menuitems => [@items],
Flow.bak:	my $n = $cops{$id}->{chain};
Flow.bak:	my $code = $cops{$id}->{type};
Flow.bak:	# check display format, may be text-field or hidden,
Flow.bak:	$debug and  print "i: $i code: $effects[$i]->{code} display: $effects[$i]->{display}\n";
Flow.bak:	my $display_type = $cops{$id}->{display};
Flow.bak:	defined $display_type or $display_type = $effects[$i]->{display};
Flow.bak:	$debug and print "to: ", $effects[$i]->{params}->[$p]->{end}, "\n";
Flow.bak:		my $frame = ${ $p{parent} }->Frame;
Flow.bak:		#return ${ $p{parent} }->Scale(
Flow.bak:		my $controller = $frame->Scale(
Flow.bak:			-variable => \$copp{$id}->[$p],
Flow.bak:			-orient => 'horizontal',
Flow.bak:			-from   =>   $effects[$i]->{params}->[$p]->{begin},
Flow.bak:			-to   =>     $effects[$i]->{params}->[$p]->{end},
Flow.bak:			-resolution => ($effects[$i]->{params}->[$p]->{resolution} 
Flow.bak:				?  $effects[$i]->{params}->[$p]->{resolution}
Flow.bak:				: abs($effects[$i]->{params}->[$p]->{end} - 
Flow.bak:					$effects[$i]->{params}->[$p]->{begin} ) > 30 
Flow.bak:						: abs($effects[$i]->{params}->[$p]->{end} - 
Flow.bak:							$effects[$i]->{params}->[$p]->{begin} ) / 100),
Flow.bak:		  -width => 12,
Flow.bak:		  -length => $p{length} ? $p{length} : 100,
Flow.bak:		  -command => sub { &effect_update($n, $id, $p, $copp{$id}->[$p]) }
Flow.bak:		if ($effects[$i]->{params}->[$p]->{hint} =~ /logarithm/) {
Flow.bak:			my $log_display = $frame->Label(
Flow.bak:				-text => exp $effects[$i]->{params}->[$p]->{default},
Flow.bak:				-width => 5,
Flow.bak:			$controller->configure(
Flow.bak:		  		-command => sub { 
Flow.bak:					&effect_update($n, $id, $p, exp $copp{$id}->[$p]);
Flow.bak:					$log_display->configure(
Flow.bak:						-text => $effects[$i]->{params}->[$p]->{name} =~ /hz/i
Flow.bak:							? int exp $copp{$id}->[$p]
Flow.bak:							: &dn(exp $copp{$id}->[$p], 1)
Flow.bak:		$log_display->grid($controller);
Flow.bak:		else { $controller->grid; }
Flow.bak:		return ${ $p{parent} }->Entry(
Flow.bak:			-textvariable =>\$copp{$id}->[$p],
Flow.bak:			-width => 6,
Flow.bak:	#		-command => sub { &effect_update($n, $id, $p, $copp{$id}->[$p]) },
Flow.bak:	$widget_c{$n}{solo}->cget('-foreground') eq q(yellow)
Flow.bak:		$widget->configure(-background => 'brown');
Flow.bak:		$widget->configure(-activebackground => 'brown');
Flow.bak:		$widget->configure(-background => $old_bg);
Flow.bak:		$widget->configure(-activebackground => $old_bg);
Flow.bak:	my $setup = &eval_iam("cs-connected");
Flow.bak:	&eval_iam("c-select $n");
Flow.bak:	&eval_iam("c-muting");
Flow.bak:	-d $a ? $a : $b;
Flow.bak:	# return track-specific version if selected,
Flow.bak:	my $version = $state_c{$n}->{active} 
Flow.bak:		? $state_c{$n}->{active} 
Flow.bak:	(grep {$_ == $version } @{$state_c{$n}->{versions}}) ? $version : undef;
Flow.bak:	$debug and print "chain $n: versions: @{$state_c{$n}->{versions}}\n";    
Flow.bak:		$state_c{$n}->{active} = $state_c{$n}->{versions}->[-1] 
Flow.bak:			if $state_c{$n}->{versions};    
Flow.bak:		$debug and print "active version, chain $n: $state_c{$n}->{active}\n\n";
Flow.bak:# VERSION: replace state_c{$n}->{active} by  &selected_version($n)
Flow.bak:	$debug and print "chain $n: active: &selected_version($n) trw: $state_t{$take{$n}}->{rw} crw: $state_c{$n}->{rw}\n";
Flow.bak:my $file_exists = -f &join_path(&this_wav_dir ,  $state_c{$n}->{targets}->{&selected_version($n)});
Flow.bak:    return MUTE if $state_c{$n}->{rw} eq MON and ! $file_exists;
Flow.bak:	return MUTE if $state_c{$n}->{rw} eq MUTE;
Flow.bak:	return MUTE if $state_t{$take{$n}}->{rw} eq MUTE;
Flow.bak:		if ($state_t{$take{$n}}->{rw} eq REC) {
Flow.bak:			if ($state_c{$n}->{rw} eq REC){
Flow.bak:				return REC if $state_c{$n}->{ch_r};
Flow.bak:			$outputs{file}->{ $mixname } = [ $oid{id} ] ;
Flow.bak:			# we can check inputs{cooked}->$n to
Flow.bak:			next if $oid{name} eq 'rec_setup' and ! $inputs{cooked}->{$n};
Flow.bak:			# check per-session setting for output oids
Flow.bak:					defined $inputs{file}->{ $state_c{$n}->{file} } 
Flow.bak:						or  $inputs{file}->{ $state_c{$n}->{file} } = [];
Flow.bak:					push @{ $inputs{file}->{ $state_c{$n}->{file} } }, $chain_id;
Flow.bak:			defined $inputs{cooked}->{$n} or $inputs{cooked}->{$n} = [];
Flow.bak:			push @{ $inputs{cooked}->{$n} }, $chain_id;
Flow.bak:				defined $outputs{file}->{ $state_c{$n}->{file} } 
Flow.bak:					or  $outputs{file}->{ $state_c{$n}->{file} } = [];
Flow.bak:				push @{ $outputs{file}->{ $state_c{$n}->{file} } }, $chain_id;
Flow.bak:# 		 	$pre_output{$_} .=  " -ea:" . 100 * scalar @chain_ids 
Flow.bak:	return if $state_c{$n}->{ch_r} == 1;
Flow.bak:	return if ! defined $state_c{$n}->{ch_r};
Flow.bak:	"-erc:$state_c{$n}->{ch_r},1
Flow.bak:	-f:$config->[0]->{raw_to_disk}->{format}"
Flow.bak:	my $offset = $dest - 1;
Flow.bak:	for my $c ( map{$width - $_ + 1} 1..$width ) {
Flow.bak:		$map .= " -erc:$c," . ( $c + $offset);
Flow.bak:		$map .= " -eac:0,"  . $c;
Flow.bak:	$hash_ref->{$key} = [] if ! defined $hash_ref->{$key};
Flow.bak:	push @{ $hash_ref->{$key} }, @vals;
Flow.bak:	return unless defined $inputs{cooked}->{$n} and scalar @{$inputs{cooked}->{$n}} == 1;
Flow.bak:	my $cooked_id = pop @{ $inputs{cooked}->{$n} }; 
Flow.bak:	my ($oid) = grep{ $cooked_id =~ /$_->{id}/ } @oids;
Flow.bak:	@{ $outputs{$oid{output}} } = grep{$_ ne $cooked_id} @{ $outputs{$oid->{output}} };
Flow.bak:inputs---->{device_name}->[chain_id1, chain_id2,... ]
Flow.bak:           {file}->$state_c{$n}->{file} }->[chain_id1, chain_id2]
Flow.bak:	       {cooked}->$n->[chain_ida chain_idb,...      ]
Flow.bak:	       {mixed}->$n->[chain_ida chain_idb,...      ]
Flow.bak:outputs--->device->{$name}[chain_id1, chain_id2,...]
Flow.bak:        |_>file->{ $file }->[chain_id1, chain_id2]
Flow.bak:		|->loop_id->[ chain_id ]
Flow.bak:intermediate->chain_id->"chain operators and routing, etc."
Flow.bak:		join " ", "-a:" . (join ",", @{ $inputs{$dev} }),
Flow.bak:			"-f:" .  $devices{$dev}->{input_format},
Flow.bak:			"-i:" .  $devices{$dev}->{ecasound_id}, 
Flow.bak:		next unless defined $inputs{cooked}->{$n} and @{ $inputs{cooked}->{$n} };
Flow.bak:			"-a:" . (join ",", @{ $inputs{cooked}->{$n} }),
Flow.bak:			"-i:loop,$n"
Flow.bak:				"-a:" . (join ",", @{ $inputs{mixed} }),
Flow.bak:				"-i:$loopb";
Flow.bak:			push @input_chains, "-a:$mixchain -i:$loopa";
Flow.bak:			push @output_chains, "-a:$mixchain -o:$loopb";
Flow.bak:		my $chain_ids = join ",",@{ $inputs{file}->{$file} };
Flow.bak:					"-a:".$chain_ids,
Flow.bak:			 		"-i:" .  &join_path(&this_wav_dir, 
Flow.bak:					         $state_c{$n}->{targets}->{&selected_version($n)}),
Flow.bak:		$debug and print "file1: $state_c{$n}->{file}\n";
Flow.bak:		my $chain_ids = join ",",@{ $outputs{file}->{$file} }; # expect one
Flow.bak:			 "-a:".$chain_ids,
Flow.bak:			 "-f:".&output_format($file),
Flow.bak:			 "-o:". &new_wav_name( $file ),
Flow.bak:				"-a:" . (join "," , @{ $outputs{$dev} }),
Flow.bak:				"-f:" . $devices{$dev}->{output_format},
Flow.bak:				"-o:". $devices{$dev}->{ecasound_id};
Flow.bak:				"-a:" . (join "," , @{ $outputs{$dev} }),
Flow.bak:				"-o:". $dev; # in this case key is the same as device name
Flow.bak:	$ecs_file   .= $config->[0]->{ecasound_globals};
Flow.bak:	$ecs_file   .= "\n\n# post-input processing\n\n";
Flow.bak:	$ecs_file   .= join "\n", sort map{ "-a:$_ $post_input{$_}"} keys %post_input;
Flow.bak:	$ecs_file   .= "\n\n# pre-output processing\n\n";
Flow.bak:	$ecs_file   .= join "\n", sort map{ "-a:$_ $pre_output{$_}"} keys %pre_output;
Flow.bak:					: $state_c{1}->{versions}->[-1] + 1
Flow.bak:		? $config->[0]->{mix_to_disk}->{format}
Flow.bak:		: $config->[0]->{mixer_out}->{format}
Flow.bak:# Multi: output 'cooked' monitor channels to side-by-side
Flow.bak:	$debug and print "rec_setup $oids[-1]->{input}\n";
Flow.bak:	map{ $oid_status{$_->{name}} = $_->{default} eq 'on' ? 1 : 0 } @oids;
Flow.bak:sub mono_to_stereo { " -erc:1,2 " }
Flow.bak:	return if ! defined $state_c{$n}->{ch_m} or $state_c{$n}{ch_m} == 1;
Flow.bak:	&route(2,$state_c{$n}->{ch_m}); # stereo signal
Flow.bak:	map{ $_->{input} = q(jack)} grep{ $_->{name} =~ /rec_/ } @oids;	
Flow.bak:	map{ $_->{output} = q(jack)} grep{ $_->{name} =~ /live|multi|stereo/ } @oids;	
Flow.bak:		&eval_iam("cs-remove $session_file");
Flow.bak:		&eval_iam("cs-load ". $session_file);
Flow.bak:		$debug and map{print "$_\n\n"}map{$e->eci($_)} qw(cs es fs st ctrl-status);
Flow.bak:	system qq(killall -9 $ecasound);
Flow.bak:	$e = Audio::Ecasound->new();
Flow.bak:	carp("Invalid chain setup, cannot arm transport.\n"),return unless &eval_iam("cs-is-valid");
Flow.bak:	&eval_iam('cs-connect');
Flow.bak:		unless &eval_iam("engine-status") eq 'not started' ;
Flow.bak:	&eval_iam('engine-launch');
Flow.bak:		unless &eval_iam("engine-status") eq 'stopped' ;
Flow.bak:	$length = &eval_iam('cs-get-length'); 
Flow.bak:	$gui and $setup_length->configure(-text => &colonize($length));
Flow.bak:	&eval_iam("cs-set-length $length") unless @record;
Flow.bak:	$gui and $clock->configure(-text => &colonize(0));
Flow.bak:	carp("Invalid chain setup, aborting start.\n"),return unless &eval_iam("cs-is-valid");
Flow.bak:	$debug2 and print "&stop_transport\n"; $e->eci('stop'); $session_label->configure(-background => $old_bg);
Flow.bak:	 $e->eci('engine-status') eq 'running' ;
Flow.bak:sub disconnect_transport { &eval_iam('cs-disconnect') }
Flow.bak:	$clock_id = $clock->repeat(1000, \&refresh_clock);
Flow.bak:	$clock->configure(-text => &colonize(&eval_iam('cs-get-position')));
Flow.bak:	eval q($clock_id->cancel);
Flow.bak:	$clock->configure(-text => &colonize(&eval_iam('cs-get-position')));
Flow.bak:	my $status = &eval_iam('engine-status');
Flow.bak:	$clock_id->cancel;
Flow.bak:	$session_label->configure(-background => $old_bg);
Flow.bak:		$time_step->configure(-text => 'Min');
Flow.bak:		$time_step->configure(-text => 'Sec');
Flow.bak:	&eval_iam(qq(cs-set-position 0));
Flow.bak:	my $end = &eval_iam(qq(cs-get-length)) - 10 ;  
Flow.bak:	&eval_iam(qq(cs-set-position $end));
Flow.bak:	$new_pos = $new_pos < $length ? $new_pos : $length - 10;
Flow.bak:	$e->eci("setpos $new_pos");
Flow.bak:	my @w = $take_frame->children;
Flow.bak:			$debug and print "t-rec $t\n";	
Flow.bak:			$debug and print "t-mon $t\n";	
Flow.bak:			$debug and print "t-mute $t\n";	
Flow.bak:		$w[$t]->configure(-background => $take_color{$status});
Flow.bak:		$widget_c{$n}->{rw}->configure(-text => $rec_status);
Flow.bak:		$widget_c{$n}->{name}->configure(-background => 'lightpink');
Flow.bak:		$widget_c{$n}->{name}->configure(-foreground => 'Black');
Flow.bak:		$widget_c{$n}->{ch_r}->configure(-background => 'LightPink');
Flow.bak:		$widget_c{$n}->{ch_r}->configure(-foreground => 'Black');
Flow.bak:		$widget_c{$n}->{ch_m}->configure( -background => $old_bg);
Flow.bak:		$widget_c{$n}->{ch_m}->configure( -foreground => 'DarkGray');
Flow.bak:		$widget_c{$n}->{version}->configure(-text => &new_version);
Flow.bak:		 $widget_c{$n}->{name}->configure(-background => 'AntiqueWhite');
Flow.bak:		 $widget_c{$n}->{name}->configure(-foreground => 'Black');
Flow.bak:		 $widget_c{$n}->{ch_r}->configure( -background => $old_bg);
Flow.bak:		 $widget_c{$n}->{ch_r}->configure( -foreground => 'DarkGray');
Flow.bak:		 $widget_c{$n}->{ch_m}->configure( -background => 'AntiqueWhite');
Flow.bak:		 $widget_c{$n}->{ch_m}->configure( -foreground => 'Black');
Flow.bak:		$widget_c{$n}->{version}->configure(-text => &selected_version($n));
Flow.bak:		 $widget_c{$n}->{name}->configure(-background => $old_bg);
Flow.bak:		 $widget_c{$n}->{ch_r}->configure( -background => $old_bg); 
Flow.bak:		 $widget_c{$n}->{ch_r}->configure( -foreground => 'Gray');
Flow.bak:		 $widget_c{$n}->{ch_m}->configure( -background => $old_bg); 
Flow.bak:		$widget_c{$n}->{ch_m}->configure( -foreground => 'Gray');
Flow.bak:		$widget_c{$n}->{version}->configure(-text => &selected_version($n));
Flow.bak:	map{ $widget_o{$_}->configure( # uses hash
Flow.bak:			-background => 
Flow.bak:			-activebackground => 
Flow.bak:## post-recording functions
Flow.bak: 		my ($n) = $outputs{file}{$k}[-1] =~ m/(\d+)/; 
Flow.bak:		if (-e $test_wav) {
Flow.bak:			if (-s $test_wav > 44100) { # 0.5s x 16 bits x 44100/s
Flow.bak:				$state_c{$n}->{active} = $state_c{$n}->{versions}->[-1];
Flow.bak:	if ( ($recorded -  $mixed) >= 1) {
Flow.bak:			$state_t{ $state_t{active} }->{rw} = MON;
Flow.bak:	my $w = $widget_c{$n}->{version};
Flow.bak:					$w->radiobutton(
Flow.bak:						-label => $v,
Flow.bak:						-variable => \$state_c{$n}->{active},
Flow.bak:						-value => $v,
Flow.bak:						-command => 
Flow.bak:		sub { $widget_c{$n}->{version}->configure(-text=>$v) 
Flow.bak:				$widget_t[0]->radiobutton(
Flow.bak:						-label => $last_version,
Flow.bak:						-variable => \$monitor_version,
Flow.bak:						-value => $last_version,
Flow.bak:						-command => sub { &mon_vert(eval $last_version) }
Flow.bak:	return if $id eq $state_c{$n}->{vol} or
Flow.bak:	          $id eq $state_c{$n}->{pan};   # skip these effects 
Flow.bak:		my $display_type = $cops{$id}->{display}; # individual setting
Flow.bak:		defined $display_type or $display_type = $effects[$i]->{display}; # template
Flow.bak:				$frame = $widget_c{$n}->{parents}->Frame->pack(
Flow.bak:					-side => 'left', 
Flow.bak:					-anchor => 'nw',)
Flow.bak:				$frame = $widget_c{$n}->{children}->Frame->pack(
Flow.bak:					-side => 'top', 
Flow.bak:					-anchor => 'nw')
Flow.bak:			my $parentage = $effects[ $effect_i{ $cops{$parent_id}->{type}} ]
Flow.bak:				->{name};
Flow.bak:			$parentage and $parentage .=  " - ";
Flow.bak:			my $eff = $frame->Menubutton(
Flow.bak:				-text => $parentage. $effects[$i]->{name}, -tearoff => 0,);
Flow.bak:			$eff->AddItems([
Flow.bak:				-command => sub {&remove_effect($id) }
Flow.bak:			$eff->grid();
Flow.bak:			for my $p (0..$effects[$i]->{count} - 1 ) {
Flow.bak:					[ 'command' => $effects[$j]->{name},
Flow.bak:						-command => sub { &add_effect ({
Flow.bak:								type => $effects[$j]->{code} } )  }
Flow.bak:			push @labels, $frame->Menubutton(
Flow.bak:					-text => $effects[$i]->{params}->[$p]->{name},
Flow.bak:					-menuitems => [@items],
Flow.bak:					-tearoff => 0,
Flow.bak:					$effects[$i]->{params}->[$p]->{name},"\n";
Flow.bak:				$sliders[0]->grid(@sliders[1..$#sliders]);
Flow.bak:				 $labels[0]->grid(@labels[1..$#labels]);
Flow.bak:	&apply_op($id) if &eval_iam("cs-is-valid");
Flow.bak:	my $n = $cops{$id}->{chain};
Flow.bak:	if ( my $parent = $cops{$id}->{belongs_to} ) {
Flow.bak:		@{ $cops{$parent}->{owns} }, "\n";
Flow.bak:		@{ $cops{$parent}->{owns} }  =  grep{ $_ ne $id}
Flow.bak:		@{ $cops{$parent}->{owns} } ; 
Flow.bak:	$debug and print "children found: ", join "|",@{$cops{$id}->{owns}},"\n";
Flow.bak:	map{&remove_effect($_)}@{ $cops{$id}->{owns} };
Flow.bak:	&remove_op($id) unless $cops{$id}->{belongs_to};
Flow.bak:	$state_c{$n}->{ops} = 
Flow.bak:		[ grep{ $_ ne $id} @{ $state_c{ $cops{$id}->{chain} }->{ops} } ];
Flow.bak:	$widget_e{$id}->destroy();
Flow.bak:	my $n = $cops{$id}->{chain};
Flow.bak:	if ( $cops{$id}->{belongs_to}) { 
Flow.bak:	$debug and print "ops list for chain $n: @{$state_c{$n}->{ops}}\n";
Flow.bak:		for my $pos ( 0.. scalar @{ $state_c{$n}->{ops} } - 1  ) {
Flow.bak:			($index = $pos), last if $state_c{$n}->{ops}->[$pos] eq $id;
Flow.bak:	 &eval_iam ("c-select $n");
Flow.bak:	&eval_iam ("cop-select ". ($state_c{$n}->{offset} + $index));
Flow.bak:	&eval_iam ("cop-remove");
Flow.bak:	# make entry in %cops with chain, code, display-type, children
Flow.bak:					  display => $effects[$i]->{display},
Flow.bak:		$debug and print "parent owns" , join " ",@{ $cops{$parent_id}->{owns}}, "\n";
Flow.bak:		push @{ $cops{$parent_id}->{owns}}, $cop_id;
Flow.bak:		$cops{$cop_id}->{belongs_to} = $parent_id;
Flow.bak:		$copp{$cop_id}->[0] = $parameter + 1; # set fx-param to the parameter number.
Flow.bak: 		my $end = scalar @{ $state_c{$n}->{ops} } - 1 ; 
Flow.bak: 			splice ( @{$state_c{$n}->{ops}}, $i+1, 0, $cop_id ), last
Flow.bak: 				if $state_c{$n}->{ops}->[$i] eq $parent_id
Flow.bak:	else { push @{$state_c{$n}->{ops} }, $cop_id; }
Flow.bak:		my $i = $effect_i{ $cops{$id}->{type} };
Flow.bak:		#for my $p ($parent_id ? 1 : 0..$effects[$i]->{count} - 1) {
Flow.bak:		# XXX support controller-type operators
Flow.bak:		for my $p (0..$effects[$i]->{count} - 1) {
Flow.bak:			my $default = $effects[$i]->{params}->[$p]->{default};
Flow.bak:	return if ! defined $state_c{$chain}->{offset}; # MIX
Flow.bak:	$debug and print "valid: ", &eval_iam("cs-is-valid"), "\n";
Flow.bak:	for my $op (0..scalar @{ $state_c{$chain}->{ops} } - 1) {
Flow.bak:		${ $state_c{$chain}->{ops} } [$op] eq $id and $controller = $op 
Flow.bak:	$debug and print "cop_id $id corresponds to track: $chain, controller: $controller, offset: $state_c{$chain}->{offset}\n";
Flow.bak:	&eval_iam ("c-select $chain");
Flow.bak:	&eval_iam ("cop-select ". ($state_c{$chain}->{offset} + $controller));
Flow.bak:	&eval_iam ("copp-select $param");
Flow.bak:	&eval_iam ("copp-set $val");
Flow.bak:	If reverb is added and it is the first user-added effect, the offset will
Flow.bak:	will also be the offset needed for our start-at-zero array. 
Flow.bak:	&eval_iam('c-select-all');
Flow.bak:			next if $chain_id =~ m/\D/; # skip id's containing non-digits
Flow.bak:			$state_c{$chain_id}->{offset} = ($quotes/2 - 1) + 1; 
Flow.bak:	$debug and print "chain: $n, offset: $state_c{$n}->{offset}\n";
Flow.bak:		next if ! defined $state_c{$n}->{offset}; # for MIX
Flow.bak: 		next if ! $state_c{$n}->{offset} ;
Flow.bak:		for my $id ( @{ $state_c{$n}->{ops} } ) {
Flow.bak:		#	next if $cops{$id}->{belongs_to}; 
Flow.bak:	my $code = $cops{$id}->{type};
Flow.bak:	$debug and print "chain: $cops{$id}->{chain} type: $cops{$id}->{type}, code: $code\n";
Flow.bak:	$code = '-' . $code . ($code =~ /:/ ? q(,) : q(:) );
Flow.bak:	my $add = "cop-add "; 
Flow.bak:	# if my parent has a parent then we need to append the -kx  operator
Flow.bak:	my $dad = $cops{$id}->{belongs_to};
Flow.bak:	$add .= " -kx" if $cops{$dad}->{belongs_to};
Flow.bak:	&eval_iam ("c-select $cops{$id}->{chain}") 
Flow.bak:		unless $cops{$id}->{belongs_to}; # avoid reset
Flow.bak:	$debug and print "children found: ", join ",", "|",@{$cops{$id}->{owns}},"|\n";
Flow.bak:	map{&apply_op($_)} @{ $cops{$id}->{owns} };
Flow.bak:	# TODO re-read effects data if ladspa or user presets are
Flow.bak:	if (-f $effects_cache and ! $opts{e}){ 
Flow.bak:	carp ("incorrect number of lines ", join ' ',$upper-$lower,scalar @lines)
Flow.bak:		if $lower + @lines - 1 != $upper;
Flow.bak:		$effects[$j]->{number} = $no;
Flow.bak:		$effects[$j]->{code} = $id;
Flow.bak:		$effects[$j]->{name} = $name;
Flow.bak:		$effects[$j]->{count} = scalar @p_names;
Flow.bak:		$effects[$j]->{params} = [];
Flow.bak:		$effects[$j]->{display} = qq(field);
Flow.bak:		map{ push @{$effects[$j]->{params}}, {name => $_} } @p_names;
Flow.bak:	map{push @ladspa_sorted, 0} ( 1 .. $aa ); # fills array slice [0..$aa-1]
Flow.bak:		 sort { $effects[$a]->{name} cmp $effects[$b]->{name} } ($aa .. $zz) ;
Flow.bak:	my @ladspa = grep {! /^\w*$/ } split "\n", &eval_iam("ladspa-register");
Flow.bak:	my @preset = grep {! /^\w*$/ } split "\n", &eval_iam("preset-register");
Flow.bak:	my @ctrl  = grep {! /^\w*$/ } split "\n", &eval_iam("ctrl-register");
Flow.bak:		-(pn:\w+)    # preset_id 
Flow.bak:		(\w.+?) # name, starting with word-char,  non-greedy
Flow.bak:		-(el:\w+),? # ladspa_id maybe followed by comma
Flow.bak:		(\w.+?) # name, starting with word-char,  non-greedy
Flow.bak:		-(k\w+):?    # ktrl_id maybe followed by colon
Flow.bak:		 $effect_i{ $effects[$i]->{code} } = $i; 
Flow.bak:		 $debug and print "i: $i code: $effects[$i]->{code} display: $effects[$i]->{display}\n";
Flow.bak:my $effects_data = io($tkeca_effects_data)->all;
Flow.bak:		$effects[$i]->{display} = qq(scale);
Flow.bak:	#print "effects code: $i stands for ", $effects[$i]->{code}, "\n";
Flow.bak:	#print "count: $effects[$i]->{count}\n";
Flow.bak:			for (1..$effects[$i]->{count}){
Flow.bak:				push @{$effects[$i]->{params}}, \%p;
Flow.bak:	# | perl -ne 'chomp; s/$ENV{LADSPA_PATH}//; system qq(analyseplugin $_)'
Flow.bak:	my $ladspa_sample_rate = 44100; # for sample-rate dependent effect
Flow.bak:		$effects_ladspa {$plugin_label}->{params} = [ @params ];
Flow.bak:		$effects_ladspa {$plugin_label}->{count} = scalar @params;
Flow.bak:		$effects_ladspa {$plugin_label}->{display} = 'scale';
Flow.bak:	my $resolution = ($end - $beg) / 100;
Flow.bak:		$resolution = ($end - $beg) / 100;
Flow.bak:		$effects[$i]->{params} = $effects_ladspa{$_}->{params};
Flow.bak:		$effects[$i]->{display} = $effects_ladspa{$_}->{display};
Flow.bak:print '-' x 60, "\n";
Flow.bak: ls $LADSPA_PATH | perl -ne 'chomp; s/$ENV{LADSPA_PATH}//; system qq(analyseplugin $_)'
Flow.bak:Must Run Real-Time: No
Flow.bak:Environment: Normal or Hard Real-Time
Flow.bak:	map{ $copp{ $state_c{$_}{vol} }->[0] = $old_vol{$_} ;
Flow.bak:	my $result2 = system "alsactl -f $file.alsa store";
Flow.bak:	map{ $copp{ $state_c{$_}{vol} }->[0] = 0} 
Flow.bak:	my $result = system "sudo alsactl -f $file.alsa restore";
Flow.bak:	map{ $time_marks[$_]->configure( 
Flow.bak:		-text => &colonize($marks[$_]),
Flow.bak:		-background => $old_bg,
Flow.bak:		for my $id (@{$state_c{$n}->{ops}}){
Flow.bak:				unless $id eq $state_c{$n}->{vol}
Flow.bak:					or $id eq $state_c{$n}->{pan};
Flow.bak:						chain => $cops{$id}->{chain},
Flow.bak:						type => $cops{$id}->{type},
Flow.bak:						parent_id => $cops{$id}->{belongs_to},
Flow.bak:		# a parameter controller, and therefore need the -kx switch
Flow.bak:	$did_apply and $gui and $ew->deiconify();
Flow.bak:	map  {$copp{ $state_c{$_}{vol} }->[0] = $old_vol{$_} ;
Flow.bak:	map{ 	$state_c_ops{$_} = $state_c{$_}->{ops} } @all_chains;
Flow.bak:	# map {&remove_op} @{ $state_c{$_}->{ops} }
Flow.bak:	map{ $time_marks[$_]->configure( 
Flow.bak:		-text => $marks[$_]
Flow.bak:		-background => $marks[$_]
Flow.bak:		@{ $state_c{$_}->{ops} }, "\n";
Flow.bak:				if (	$state_c{$n}->{vol} eq $id or
Flow.bak:						$state_c{$n}->{pan} eq $id  ){
Flow.bak:		} @{ $state_c{$_}->{ops} }
Flow.bak:	map{ $state_c{$_}->{ops} = $state_c_ops{$_} } @all_chains;
Flow.bak:	# restore ops->chain mapping
Flow.bak:				if (	$state_c{$n}->{vol} eq $id or
Flow.bak:						$state_c{$n}->{pan} eq $id  ){
Flow.bak:					$copp{$id}->[0] = $old_copp{$id}->[0];
Flow.bak:			} @{ $state_c{$_}->{ops} }
Flow.bak:		for my $id (@{$state_c{$n}->{ops}}){
Flow.bak:				unless $id eq $state_c{$n}->{vol}
Flow.bak:					or $id eq $state_c{$n}->{pan};
Flow.bak:						chain => $cops{$id}->{chain},
Flow.bak:						type => $cops{$id}->{type},
Flow.bak:						parent_id => $cops{$id}->{belongs_to},
Flow.bak:		# a parameter controller, and therefore need the -kx switch
Flow.bak:	# $ew->deiconify or $ew->iconify;
Flow.bak:	-f $file or carp ("file: $file not found\n"),return 0;
Flow.bak:						. q({ $hash_ref->{)
Flow.bak:						. q(} } if defined $hash_ref->{)
Flow.bak:		map{$time_marks[$_]->configure( -background => $old_bg) unless ! $marks[$_] } 1..$#time_marks ;
Flow.bak:		map{$_->configure( -background => 'lightblue') } @time_marks[1..$#time_marks] ;
Flow.bak:		my $here = &eval_iam("cs-get-position");
Flow.bak:		$widget->configure(
Flow.bak:			-text => &colonize($here),
Flow.bak:			-background => $old_bg,
Flow.bak:		&eval_iam(qq(cs-set-position $marks[$marker]));
Flow.bak:Audio::Ecasound::Flow - Perl extensions for multitrack audio
Flow.bak:  my $ui = Audio::Ecasound::Flow::GUI->new("Tk");
Flow.bak:  my $ui = Audio::Ecasound::Flow::GUI->new("text");
Flow.bak:			effects => 'force-reload',
Flow.bak:	$ui->main(%options);
Flow.bak:Joel Roth, E<lt>jroth@dsl-verizon.netE<gt>
Flow.pm:$ladspa_sample_rate = 44100; # for sample-rate dependent effect
Flow.pm:# for sample-rate dependent LADSPA effect parameters, ideally 
Flow.pm:# should change with per-project sample rates in parameters.pl
Flow.pm:$unit  = 1; # fast-forward multiplier default;
Flow.pm:	-d $wav_dir or croak qq(wave_directory: "$wav_dir" in Config.pm
Flow.pm:	$::OUT = $term->OUT || \*STDOUT;
Flow.pm:		($user_input) = $term->readline($prompt) ;
Flow.pm:		$term->addhistory($user_input) ;
Flow.pm:			$parser->command($predicate) or print ("Returned false\n");
Flow.pm:			$parser->command($user_input) or print ("Parse failed\n");
Flow.pm:	my $result = $e->eci($command);
Flow.pm:	my $errmsg = $e->errmsg();
Flow.pm:	$e->errmsg('');
Flow.pm:	$config = YAML::Tiny->new;
Flow.pm:	$yaml = io($yamlfile)->all if -f $yamlfile;
Flow.pm:	$config = YAML::Tiny->read_string($yaml);
Flow.pm:	ref $config->[0] or croak "not ref!";
Flow.pm:	*cfg = \%{$config->[0]}; # alias
Flow.pm:	#print $config->write_string();
Flow.pm:	#print $config->write_string();
Flow.pm:	$debug and print $config->write_string; 
Flow.pm:	my $val = $parent->{$key};
Flow.pm:		or map{$parent->{$key} =~ s/$_/$subst{$_}/} keys %subst;
Flow.pm:	$debug and print "\$session: $session name: $hash->{name} create: $hash->{create}\n";
Flow.pm:	$session_name = $hash->{name} ? $hash->{name} : $session;
Flow.pm:	$hash->{create} and 
Flow.pm:	carp ("missing session file $sf\n") unless -f $sf;
Flow.pm:	$gui and $session_label->configure(
Flow.pm:		-text => uc $session_name, 
Flow.pm:		-background => 'lightyellow',
Flow.pm:	                        # indexed by {$id}->[$param_no]
Flow.pm:	map{ $_->destroy } map{ $_->children } $effect_frame;
Flow.pm:	my @children = $take_frame->children;
Flow.pm:	map{ $_->destroy  } @children[1..$#children];
Flow.pm:	@children = $track_frame->children;
Flow.pm:	map{ $_->destroy  } @children[11..$#children]; # fragile
Flow.pm:	-d $dir 
Flow.pm:	$state_t{$t}->{rw} = $::REC;
Flow.pm:	#&set_active_version($i) if ! defined $state_c{$i}->{active};
Flow.pm:	$state_c{$i}->{ops} = [] if ! defined $state_c{$i}->{ops};
Flow.pm:	$state_c{$i}->{rw} = $::REC if ! defined $state_c{$i}->{rw};
Flow.pm:	# return if $opts{m} or ! -e &join_path(&session_dir,$statestore);
Flow.pm:	$state_t{$t}->{rw} = $::MUTE; 
Flow.pm:	$state_t{$t}->{rw} = $::MON;
Flow.pm:	$state_c{$i}->{rw} = $::REC;
Flow.pm:	$state_c{$i}->{ch_m} = $ch_m;
Flow.pm:	$state_c{$i}->{ch_r} = $ch_r;
Flow.pm:	$state_c{$i}->{file} = $name;
Flow.pm:	print "getting versions for chain $n, state_c{$n}->{file}\n";
Flow.pm:			$state_c{$n}->{file},
Flow.pm:		delete $state_c{$n}->{targets};
Flow.pm:		$state_c{$n}->{targets} = { %versions };
Flow.pm:		 $state_c{$n}->{versions} = [ sort { $a <=> $b } 
Flow.pm:		 	keys %{$state_c{$n}->{targets}} ];
Flow.pm:		$debug and print join " ", "versions: ",@ {$state_c{$n}->{versions}} , "\n\n";
Flow.pm:		my $this_last = $state_c{$n}->{versions}->[-1];
Flow.pm:		#$state_c{$n}->{active} = $state_c{$n}->{versions}->[-1]
Flow.pm:		#	unless grep{ $state_c{$n}->{active} == $_ }
Flow.pm:		#		@{$state_c{$n}->{versions}};
Flow.pm:	my $cmd = qq(find $a  -name '*.wav' -size 44c);
Flow.pm:	#map {system qq(ls -l $_ ) } @wavs; exit;
Flow.pm:	map { print ($_, "\n") if -s == 44 } @wavs; 
Flow.pm:	map { unlink $_ if -s == 44 } @wavs; 
Flow.pm:					$state_t{$t}->{rw} = $::REC;
Flow.pm:			$t--;
Flow.pm:			my @candidate = $take_frame->children;
Flow.pm:			$candidate[-1]->destroy;
Flow.pm:	$state_t{$t}->{rw} = $status; 
Flow.pm:	$mw = MainWindow->new; 
Flow.pm:	$mw->title("Tk Ecmd"); 
Flow.pm:	$ew = $mw->Toplevel;
Flow.pm:	$ew->title("Effect Window");
Flow.pm:	$ew->withdraw;
Flow.pm:	$canvas = $ew->Scrolled('Canvas')->pack;
Flow.pm:	$canvas->configure(
Flow.pm:		-width => 900,
Flow.pm:		-height => 600,	
Flow.pm:# 		-width => 1000,
Flow.pm:# 		-height => 4000,	
Flow.pm:	$effect_frame = $canvas->Frame;
Flow.pm:	my $id = $canvas->createWindow(30,30, -window => $effect_frame,
Flow.pm:											-anchor => 'nw');
Flow.pm:	$session_label = $mw->Label->pack(-fill => 'both');
Flow.pm:	$old_bg = $session_label->cget('-background');
Flow.pm:	$time_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$transport_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$oid_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$clock_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$track_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$take_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$take_label = $take_frame->Menubutton(-text => "Group",-tearoff => 0,)->pack(-side => 'left');
Flow.pm:	$add_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$perl_eval_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$iam_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:	$load_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
Flow.pm:#	my $blank = $mw->Label->pack(-side => 'left');
Flow.pm:	$sn_label = $load_frame->Label(-text => "Enter session name:")->pack(-side => 'left');
Flow.pm:	$sn_text = $load_frame->Entry(-textvariable => \$session, -width => 45)->pack(-side => 'left');
Flow.pm:	$sn_load = $load_frame->Button->pack(-side => 'left');;
Flow.pm:#	$sn_load_nostate = $load_frame->Button->pack(-side => 'left');;
Flow.pm:	$sn_new = $load_frame->Button->pack(-side => 'left');;
Flow.pm:	$sn_quit = $load_frame->Button->pack(-side => 'left');
Flow.pm:	$build_track_label = $add_frame->Label(-text => "Track")->pack(-side => 'left');
Flow.pm:	$build_track_text = $add_frame->Entry(-textvariable => \$track_name, -width => 12)->pack(-side => 'left');
Flow.pm:	$build_track_rec_label = $add_frame->Label(-text => "REC")->pack(-side => 'left');
Flow.pm:	$build_track_rec_text = $add_frame->Entry(-textvariable => \$ch_r, -width => 2)->pack(-side => 'left');
Flow.pm:	$build_track_mon_label = $add_frame->Label(-text => "MON")->pack(-side => 'left');
Flow.pm:	$build_track_mon_text = $add_frame->Entry(-textvariable => \$ch_m, -width => 2)->pack(-side => 'left');
Flow.pm:	$build_track_add = $add_frame->Button->pack(-side => 'left');;
Flow.pm:	$sn_load->configure(
Flow.pm:		-text => 'Load',
Flow.pm:		-command => \&load_session,
Flow.pm:	$sn_new->configure( 
Flow.pm:		-text => 'New',
Flow.pm:		-command => sub { &load_session({create => 1}) },
Flow.pm:	$sn_quit->configure(-text => "Quit",
Flow.pm:		 -command => sub { 
Flow.pm:	$build_track_add->configure( 
Flow.pm:			-text => 'Add',
Flow.pm:			-command => sub { &add_track($track_name) }
Flow.pm:	$build_new_take->configure( 
Flow.pm:			-text => 'New Group',
Flow.pm:			-command =>
Flow.pm:	map{ push @widgets, $track_frame->Label(-text => $_)  } @labels;
Flow.pm:	$widgets[0]->grid(@widgets[1..$#widgets]);
Flow.pm:	$iam_label = $iam_frame->Label(-text => "IAM Command")
Flow.pm:		->pack(-side => 'left');;
Flow.pm:	$iam_text = $iam_frame->Entry( 
Flow.pm:		-textvariable => \$iam, -width => 65)
Flow.pm:		->pack(-side => 'left');;
Flow.pm:	$iam_execute = $iam_frame->Button(
Flow.pm:			-text => 'Execute',
Flow.pm:			-command => sub { print &eval_iam($iam), "\n" }
Flow.pm:		)->pack(-side => 'left');;
Flow.pm:	my $perl_eval_label = $perl_eval_frame->Label(
Flow.pm:		-text => "Perl Command")
Flow.pm:		->pack(-side => 'left');;
Flow.pm:	my $perl_eval_text = $perl_eval_frame->Entry(
Flow.pm:		-textvariable => \$perl_eval, -width => 65)
Flow.pm:		->pack(-side => 'left');;
Flow.pm:	my $perl_eval_execute = $perl_eval_frame->Button(
Flow.pm:			-text => 'Execute',
Flow.pm:			-command => sub { eval $perl_eval  }
Flow.pm:		)->pack(-side => 'left');;
Flow.pm:	$transport_label = $transport_frame->Label(
Flow.pm:		-text => 'TRANSPORT',
Flow.pm:		-width => 12,
Flow.pm:		)->pack(-side => 'left');;
Flow.pm:	$transport_setup_and_connect  = $transport_frame->Button->pack(-side => 'left');;
Flow.pm:	$transport_start = $transport_frame->Button->pack(-side => 'left');
Flow.pm:	$transport_stop = $transport_frame->Button->pack(-side => 'left');
Flow.pm:	$transport_setup = $transport_frame->Button->pack(-side => 'left');;
Flow.pm:	$transport_connect = $transport_frame->Button->pack(-side => 'left');;
Flow.pm:	$transport_disconnect = $transport_frame->Button->pack(-side => 'left');;
Flow.pm:	$transport_new = $transport_frame->Button->pack(-side => 'left');;
Flow.pm:	$transport_stop->configure(-text => "Stop",
Flow.pm:	-command => sub { 
Flow.pm:	$transport_start->configure(
Flow.pm:		-text => "Start!",
Flow.pm:		-command => sub { 
Flow.pm:			$session_label->configure(-background => 'lightpink') 
Flow.pm:			$session_label->configure(-background => 'lightgreen') 
Flow.pm:	$transport_setup_and_connect->configure(
Flow.pm:			-text => 'Generate and connect',
Flow.pm:			-command => sub {&setup_transport; &connect_transport}
Flow.pm:	$transport_setup->configure(
Flow.pm:			-text => 'Generate chain setup',
Flow.pm:			-command => \&setup_transport,
Flow.pm:	$transport_connect->configure(
Flow.pm:			-text => 'Connect chain setup',
Flow.pm:			-command => \&connect_transport,
Flow.pm:	$transport_disconnect->configure(
Flow.pm:			-text => 'Disconnect setup',
Flow.pm:			-command => sub { &disconnect_transport },
Flow.pm:	$transport_new->configure(
Flow.pm:			-text => 'New Engine',
Flow.pm:			-command => \&new_engine,
Flow.pm:	my $time_label = $clock_frame->Label(
Flow.pm:		-text => 'TIME', 
Flow.pm:		-width => 12);
Flow.pm:	$clock = $clock_frame->Label(
Flow.pm:		-text => '0:00', 
Flow.pm:		-width => 8,
Flow.pm:		-background => 'orange',
Flow.pm:	my $length_label = $clock_frame->Label(
Flow.pm:		-text => 'LENGTH',
Flow.pm:		-width => 10,
Flow.pm:	$setup_length = $clock_frame->Label(
Flow.pm:	#	-width => 8,
Flow.pm:		$w->pack(-side => 'left');	
Flow.pm:	my $mark_frame = $time_frame->Frame->pack(
Flow.pm:		-side => 'bottom', 
Flow.pm:		-fill => 'both');
Flow.pm:	my $fast_frame = $time_frame->Frame->pack(
Flow.pm:		-side => 'bottom', 
Flow.pm:		-fill => 'both');
Flow.pm:	my $jump_label = $fast_frame->Label(-text => q(JUMP), -width => 12);
Flow.pm:	my $mark_label = $mark_frame->Label(-text => q(MARK), -width => 12);
Flow.pm:	my @minuses = map{ - $_ } reverse @pluses;
Flow.pm:	my @fw = map{ my $d = $_; $fast_frame->Button(
Flow.pm:			-text => $d,
Flow.pm:			-command => sub { &jump($d) },
Flow.pm:	my @rew = map{ my $d = $_; $fast_frame->Button(
Flow.pm:			-text => $d,
Flow.pm:			-command => sub { &jump($d) },
Flow.pm:	my $beg = $fast_frame->Button(
Flow.pm:			-text => 'Beg',
Flow.pm:			-command => \&to_start,
Flow.pm:	my $end = $fast_frame->Button(
Flow.pm:			-text => 'End',
Flow.pm:			-command => \&to_end,
Flow.pm:	$time_step = $fast_frame->Button( 
Flow.pm:			-text => 'Sec',
Flow.pm:			$w->pack(-side => 'left')
Flow.pm:	$time_step->configure (-command => \&toggle_unit);
Flow.pm:	push @label_and_arm, $mark_frame->Button(
Flow.pm:		-text => 'Set',
Flow.pm:		-command => sub { &arm_mark },
Flow.pm:	map { push @time_marks, $mark_frame->Button( 
Flow.pm:		-text => $_,
Flow.pm:		-command => sub { &mark(eval $_)},
Flow.pm:		-background => $marks[$_] ? $old_bg : 'lightblue',
Flow.pm:	# map { $time_marks[$_]->configure( -command => sub { # &mark($_)} ) } @m[1..$#m];
Flow.pm:		$time_marks[$m]->configure( -command => sub { &mark($m)} )
Flow.pm:	#$time_marks[3]->configure( -background => 'orange' );
Flow.pm:#	 map { $time_marks[$_]->configure(-background => 'orange')} @m;
Flow.pm: 		$w->pack(-side => 'left')
Flow.pm:#	$time_marks[0]->grid(@time_marks[@m]);
Flow.pm:	my $outputs = $oid_frame->Label(-text => 'OUTPUTS', -width => 12);
Flow.pm:		# print "gui oid name: $oid->{name} status: $oid_status{$oid->{name}}\n";
Flow.pm:		next if $oid->{name} =~ m/setup/;
Flow.pm:		push @oid_name, $oid->{name};
Flow.pm:		my $oid_button = $oid_frame->Button( 
Flow.pm:			-text => ucfirst $oid->{name},
Flow.pm:			-background => 
Flow.pm:				$oid_status{$oid->{name}} ?  'AntiqueWhite' : $old_bg,
Flow.pm:			-activebackground => 
Flow.pm:				$oid_status{$oid->{name}} ? 'AntiqueWhite' : $old_bg
Flow.pm:		$widget_o{$oid->{name}} = $oid_button;
Flow.pm:		$widget_o[$i]->configure(
Flow.pm:			-command => sub { 
Flow.pm:				$widget_o[$i]->configure( -background => 
Flow.pm:			-activebackground => 
Flow.pm:	my $toggle_jack = $oid_frame->Button;
Flow.pm:	$toggle_jack->configure(
Flow.pm:		-text => q(Jack ON/OFF),
Flow.pm:		-command => sub {
Flow.pm:			my $color = $toggle_jack->cget( -background );
Flow.pm:	map { $_ -> pack(-side => 'left') } ($outputs, @widget_o);
Flow.pm:	$button->configure(-background => $color,
Flow.pm:						-activebackground => $color);
Flow.pm:	$setup_length->configure(-background =>
Flow.pm:	$setup_length->after(10000, 
Flow.pm:		sub{ $setup_length->configure(-background => $old_bg) }
Flow.pm:		my $name = $take_frame->Menubutton(
Flow.pm:				-text => ucfirst $tname,
Flow.pm:				-tearoff =>0,
Flow.pm:			)->pack(-side => 'left');
Flow.pm:		$name->AddItems([
Flow.pm:			-background => $old_bg,
Flow.pm:			-command => sub { 
Flow.pm:		$name->AddItems([
Flow.pm:			-background => $old_bg,
Flow.pm:			-command => sub {
Flow.pm:		$name->AddItems([
Flow.pm:			-background => $old_bg,
Flow.pm:			-command => sub {
Flow.pm:#	( map{ $_->destroy } @global_version_buttons ) if @global_version_buttons; 
Flow.pm:    my @children = $widget_t[1]->children;
Flow.pm:		$_->cget(-value) and $_->destroy;
Flow.pm:		next unless grep{  grep{ $v == $_ } @{ $state_c{$_}->{versions} } }
Flow.pm:			$widget_t[1]->radiobutton(
Flow.pm:				-label => ($v ? $v : ''),
Flow.pm:				-variable => \$monitor_version,
Flow.pm:				-value => $v,
Flow.pm:				-command => sub { 
Flow.pm:					$state_t{2}->{rw} = $::MON; ### HARDCODED SECOND TAKE; MIX
Flow.pm:	my $stub = $state_c{$n}->{active};
Flow.pm:	$name = $track_frame->Label(
Flow.pm:			-text => $state_c{$n}->{file},
Flow.pm:			-justify => 'left');
Flow.pm:	$version = $track_frame->Menubutton( 
Flow.pm:					-text => $stub,
Flow.pm:					-tearoff => 0);
Flow.pm:	for my $v (undef, @{$state_c{$n}->{versions}}) {
Flow.pm:					$version->radiobutton(
Flow.pm:						-label => ($v ? $v: ''),
Flow.pm:						-variable => \$state_c{$n}->{active},
Flow.pm:						-value => $v,
Flow.pm:						-command => 
Flow.pm:		sub { $version->configure(-text=> &selected_version($n) ) 
Flow.pm:	$ch_r = $track_frame->Menubutton(
Flow.pm:					-textvariable => \$state_c{$n}->{ch_r},
Flow.pm:					-tearoff => 0,
Flow.pm:					$ch_r->radiobutton(
Flow.pm:						-label => $v,
Flow.pm:						-variable => \$state_c{$n}->{ch_r},
Flow.pm:						-value => $v,
Flow.pm:						-command => sub { 
Flow.pm:							$state_c{$n}->{rw} = $::REC;
Flow.pm:	$ch_m = $track_frame->Menubutton(
Flow.pm:					-textvariable => \$state_c{$n}->{ch_m},
Flow.pm:					-tearoff => 0,
Flow.pm:					$ch_m->radiobutton(
Flow.pm:						-label => $v,
Flow.pm:						-variable => \$state_c{$n}->{ch_m},
Flow.pm:						-value => $v,
Flow.pm:						-command => sub { 
Flow.pm:							$state_c{$n}->{rw} = $::MON;
Flow.pm:	$rw = $track_frame->Menubutton(
Flow.pm:		-text => $state_c{$n}->{rw},
Flow.pm:		-tearoff => 0,
Flow.pm:				-foreground => 'red',
Flow.pm:				-command  => sub { 
Flow.pm:					$state_c{$n}->{rw} = $::REC;
Flow.pm:				-command  => sub { 
Flow.pm:					$state_c{$n}->{rw} = $::MON;
Flow.pm:				-command  => sub { 
Flow.pm:					$state_c{$n}->{rw} = $::MUTE;
Flow.pm:	map{$rw->AddItems($_) unless $n == 1} @items; # MIX CONDITIONAL
Flow.pm:	$state_c{$n}->{rw} = $::MON if $n == 1;          # MIX
Flow.pm:	$mute = $track_frame->Button;
Flow.pm:	$mute->configure( -command => sub { &toggle_muting($mute, $n) });
Flow.pm:	$mute = $track_frame->Button(
Flow.pm:	  		-command => sub { 
Flow.pm:				if ($copp{$vol_id}->[0]) {  # non-zero volume
Flow.pm:					$old_vol{$n}=$copp{$vol_id}->[0];
Flow.pm:					$copp{$vol_id}->[0] = 0;
Flow.pm:					$mute->configure(-background => 'brown');
Flow.pm:					$mute->configure(-activebackground => 'brown');
Flow.pm:					$copp{$vol_id}->[0] = $old_vol{$n};
Flow.pm:					$mute->configure(-background => $old_bg);
Flow.pm:					$mute->configure(-activebackground => $old_bg);
Flow.pm:	$solo = $track_frame->Button;
Flow.pm:	$solo->configure( -command => sub {
Flow.pm:		return if ! grep{/$session_name/} &eval_iam(q(cs-connected));
Flow.pm:			$solo->configure(-foreground => $old_bg );
Flow.pm:			$solo->configure(-activeforeground => $old_bg );
Flow.pm:			$solo->configure(-foreground => q(yellow) );
Flow.pm:			$solo->configure(-activeforeground => q(yellow) );
Flow.pm:	$unity = $track_frame->Button(
Flow.pm:	  		-command => sub { 
Flow.pm:				$copp{$vol_id}->[0] = 100;
Flow.pm:	$center = $track_frame->Button(
Flow.pm:	  	-command => sub { 
Flow.pm:			$copp{$pan_id}->[0] = 50;
Flow.pm:	my $effects = $effect_frame->Frame->pack(-fill => 'both');;
Flow.pm:	# effects, held by widget_c->n->effects is the frame for
Flow.pm:	my $parents = ${ $widget_c{$n}->{effects} }->Frame->pack(-fill => 'x');
Flow.pm:	my $children = ${ $widget_c{$n}->{effects} }->Frame->pack(-fill => 'x');
Flow.pm:	$widget_c{$n}->{parents} = $parents;   # parents belong here
Flow.pm:	$widget_c{$n}->{children} = $children; # children go here
Flow.pm:	$parents->Label(-text => (uc $stub) )->pack(-side => 'left');
Flow.pm:					 $e_bound{ladspa}{b}-1, 
Flow.pm:					 $e_bound{ladspa}{c}-1, 
Flow.pm:					 $e_bound{ladspa}{d}-1, 
Flow.pm:	$name->grid($version, $rw, $ch_r, $ch_m, $vol, $mute, $unity, $pan, $center, @add_effect);
Flow.pm:				cop_id => $state_c{$n}->{vol}, # often undefined
Flow.pm:	$state_c{$n}->{vol} = $vol_id;  # save the id for next time
Flow.pm:				cop_id => $state_c{$n}->{pan}, # often undefined
Flow.pm:	$state_c{$n}->{pan} = $vol_id;  # save the id for next time
Flow.pm:		print "adding effect: $effects[$j]->{name}\n";
Flow.pm:			[ 'command' => "$effects[$j]->{count} $effects[$j]->{name}" ,
Flow.pm:				-command  => sub { 
Flow.pm:					 &add_effect( {chain => $n, type => $effects[$j]->{code} } ); 
Flow.pm:					$ew->deiconify; # display effects window
Flow.pm:	$widget = $track_frame->Menubutton(
Flow.pm:		-text => $label,
Flow.pm:		-tearoff =>0,
Flow.pm:		-menuitems => [@items],
Flow.pm:	my $n = $cops{$id}->{chain};
Flow.pm:	my $code = $cops{$id}->{type};
Flow.pm:	# check display format, may be text-field or hidden,
Flow.pm:	$debug and  print "i: $i code: $effects[$i]->{code} display: $effects[$i]->{display}\n";
Flow.pm:	my $display_type = $cops{$id}->{display};
Flow.pm:	defined $display_type or $display_type = $effects[$i]->{display};
Flow.pm:	$debug and print "to: ", $effects[$i]->{params}->[$p]->{end}, "\n";
Flow.pm:		my $frame = ${ $p{parent} }->Frame;
Flow.pm:		#return ${ $p{parent} }->Scale(
Flow.pm:		my $controller = $frame->Scale(
Flow.pm:			-variable => \$copp{$id}->[$p],
Flow.pm:			-orient => 'horizontal',
Flow.pm:			-from   =>   $effects[$i]->{params}->[$p]->{begin},
Flow.pm:			-to   =>     $effects[$i]->{params}->[$p]->{end},
Flow.pm:			-resolution => ($effects[$i]->{params}->[$p]->{resolution} 
Flow.pm:				?  $effects[$i]->{params}->[$p]->{resolution}
Flow.pm:				: abs($effects[$i]->{params}->[$p]->{end} - 
Flow.pm:					$effects[$i]->{params}->[$p]->{begin} ) > 30 
Flow.pm:						: abs($effects[$i]->{params}->[$p]->{end} - 
Flow.pm:							$effects[$i]->{params}->[$p]->{begin} ) / 100),
Flow.pm:		  -width => 12,
Flow.pm:		  -length => $p{length} ? $p{length} : 100,
Flow.pm:		  -command => sub { &effect_update($n, $id, $p, $copp{$id}->[$p]) }
Flow.pm:		if ($effects[$i]->{params}->[$p]->{hint} =~ /logarithm/) {
Flow.pm:			my $log_display = $frame->Label(
Flow.pm:				-text => exp $effects[$i]->{params}->[$p]->{default},
Flow.pm:				-width => 5,
Flow.pm:			$controller->configure(
Flow.pm:		  		-command => sub { 
Flow.pm:					&effect_update($n, $id, $p, exp $copp{$id}->[$p]);
Flow.pm:					$log_display->configure(
Flow.pm:						-text => $effects[$i]->{params}->[$p]->{name} =~ /hz/i
Flow.pm:							? int exp $copp{$id}->[$p]
Flow.pm:							: &dn(exp $copp{$id}->[$p], 1)
Flow.pm:		$log_display->grid($controller);
Flow.pm:		else { $controller->grid; }
Flow.pm:		return ${ $p{parent} }->Entry(
Flow.pm:			-textvariable =>\$copp{$id}->[$p],
Flow.pm:			-width => 6,
Flow.pm:	#		-command => sub { &effect_update($n, $id, $p, $copp{$id}->[$p]) },
Flow.pm:	$widget_c{$n}{solo}->cget('-foreground') eq q(yellow)
Flow.pm:		$widget->configure(-background => 'brown');
Flow.pm:		$widget->configure(-activebackground => 'brown');
Flow.pm:		$widget->configure(-background => $old_bg);
Flow.pm:		$widget->configure(-activebackground => $old_bg);
Flow.pm:	my $setup = &eval_iam("cs-connected");
Flow.pm:	&eval_iam("c-select $n");
Flow.pm:	&eval_iam("c-muting");
Flow.pm:	-d $a ? $a : $b;
Flow.pm:	# return track-specific version if selected,
Flow.pm:	my $version = $state_c{$n}->{active} 
Flow.pm:		? $state_c{$n}->{active} 
Flow.pm:	(grep {$_ == $version } @{$state_c{$n}->{versions}}) ? $version : undef;
Flow.pm:	$debug and print "chain $n: versions: @{$state_c{$n}->{versions}}\n";    
Flow.pm:		$state_c{$n}->{active} = $state_c{$n}->{versions}->[-1] 
Flow.pm:			if $state_c{$n}->{versions};    
Flow.pm:		$debug and print "active version, chain $n: $state_c{$n}->{active}\n\n";
Flow.pm:# VERSION: replace state_c{$n}->{active} by  &selected_version($n)
Flow.pm:	$debug and print "chain $n: active: &selected_version($n) trw: $state_t{$take{$n}}->{rw} crw: $state_c{$n}->{rw}\n";
Flow.pm:my $file_exists = -f &join_path(&this_wav_dir ,  $state_c{$n}->{targets}->{&selected_version($n)});
Flow.pm:    return $::MUTE if $state_c{$n}->{rw} eq $::MON and ! $file_exists;
Flow.pm:	return $::MUTE if $state_c{$n}->{rw} eq $::MUTE;
Flow.pm:	return $::MUTE if $state_t{$take{$n}}->{rw} eq $::MUTE;
Flow.pm:		if ($state_t{$take{$n}}->{rw} eq $::REC) {
Flow.pm:			if ($state_c{$n}->{rw} eq $::REC){
Flow.pm:				return $::REC if $state_c{$n}->{ch_r};
Flow.pm:			$outputs{file}->{ $mixname } = [ $oid{id} ] ;
Flow.pm:			# we can check inputs{cooked}->$n to
Flow.pm:			next if $oid{name} eq 'rec_setup' and ! $inputs{cooked}->{$n};
Flow.pm:			# check per-session setting for output oids
Flow.pm:					defined $inputs{file}->{ $state_c{$n}->{file} } 
Flow.pm:						or  $inputs{file}->{ $state_c{$n}->{file} } = [];
Flow.pm:					push @{ $inputs{file}->{ $state_c{$n}->{file} } }, $chain_id;
Flow.pm:			defined $inputs{cooked}->{$n} or $inputs{cooked}->{$n} = [];
Flow.pm:			push @{ $inputs{cooked}->{$n} }, $chain_id;
Flow.pm:				defined $outputs{file}->{ $state_c{$n}->{file} } 
Flow.pm:					or  $outputs{file}->{ $state_c{$n}->{file} } = [];
Flow.pm:				push @{ $outputs{file}->{ $state_c{$n}->{file} } }, $chain_id;
Flow.pm:# 		 	$pre_output{$_} .=  " -ea:" . 100 * scalar @chain_ids 
Flow.pm:	return if $state_c{$n}->{ch_r} == 1;
Flow.pm:	return if ! defined $state_c{$n}->{ch_r};
Flow.pm:	"-erc:$state_c{$n}->{ch_r},1
Flow.pm:	-f:$config->[0]->{raw_to_disk}->{format}"
Flow.pm:	my $offset = $dest - 1;
Flow.pm:	for my $c ( map{$width - $_ + 1} 1..$width ) {
Flow.pm:		$map .= " -erc:$c," . ( $c + $offset);
Flow.pm:		$map .= " -eac:0,"  . $c;
Flow.pm:	$hash_ref->{$key} = [] if ! defined $hash_ref->{$key};
Flow.pm:	push @{ $hash_ref->{$key} }, @vals;
Flow.pm:	return unless defined $inputs{cooked}->{$n} and scalar @{$inputs{cooked}->{$n}} == 1;
Flow.pm:	my $cooked_id = pop @{ $inputs{cooked}->{$n} }; 
Flow.pm:	my ($oid) = grep{ $cooked_id =~ /$_->{id}/ } @oids;
Flow.pm:	@{ $outputs{$oid{output}} } = grep{$_ ne $cooked_id} @{ $outputs{$oid->{output}} };
Flow.pm:inputs---->{device_name}->[chain_id1, chain_id2,... ]
Flow.pm:           {file}->$state_c{$n}->{file} }->[chain_id1, chain_id2]
Flow.pm:	       {cooked}->$n->[chain_ida chain_idb,...      ]
Flow.pm:	       {mixed}->$n->[chain_ida chain_idb,...      ]
Flow.pm:outputs--->device->{$name}[chain_id1, chain_id2,...]
Flow.pm:        |_>file->{ $file }->[chain_id1, chain_id2]
Flow.pm:		|->loop_id->[ chain_id ]
Flow.pm:intermediate->chain_id->"chain operators and routing, etc."
Flow.pm:		join " ", "-a:" . (join ",", @{ $inputs{$dev} }),
Flow.pm:			"-f:" .  $devices{$dev}->{input_format},
Flow.pm:			"-i:" .  $devices{$dev}->{ecasound_id}, 
Flow.pm:		next unless defined $inputs{cooked}->{$n} and @{ $inputs{cooked}->{$n} };
Flow.pm:			"-a:" . (join ",", @{ $inputs{cooked}->{$n} }),
Flow.pm:			"-i:loop,$n"
Flow.pm:				"-a:" . (join ",", @{ $inputs{mixed} }),
Flow.pm:				"-i:$loopb";
Flow.pm:			push @input_chains, "-a:$mixchain -i:$loopa";
Flow.pm:			push @output_chains, "-a:$mixchain -o:$loopb";
Flow.pm:		my $chain_ids = join ",",@{ $inputs{file}->{$file} };
Flow.pm:					"-a:".$chain_ids,
Flow.pm:			 		"-i:" .  &join_path(&this_wav_dir, 
Flow.pm:					         $state_c{$n}->{targets}->{&selected_version($n)}),
Flow.pm:		$debug and print "file1: $state_c{$n}->{file}\n";
Flow.pm:		my $chain_ids = join ",",@{ $outputs{file}->{$file} }; # expect one
Flow.pm:			 "-a:".$chain_ids,
Flow.pm:			 "-f:".&output_format($file),
Flow.pm:			 "-o:". &new_wav_name( $file ),
Flow.pm:				"-a:" . (join "," , @{ $outputs{$dev} }),
Flow.pm:				"-f:" . $devices{$dev}->{output_format},
Flow.pm:				"-o:". $devices{$dev}->{ecasound_id};
Flow.pm:				"-a:" . (join "," , @{ $outputs{$dev} }),
Flow.pm:				"-o:". $dev; # in this case key is the same as device name
Flow.pm:	$ecs_file   .= $config->[0]->{ecasound_globals};
Flow.pm:	$ecs_file   .= "\n\n# post-input processing\n\n";
Flow.pm:	$ecs_file   .= join "\n", sort map{ "-a:$_ $post_input{$_}"} keys %post_input;
Flow.pm:	$ecs_file   .= "\n\n# pre-output processing\n\n";
Flow.pm:	$ecs_file   .= join "\n", sort map{ "-a:$_ $pre_output{$_}"} keys %pre_output;
Flow.pm:					: $state_c{1}->{versions}->[-1] + 1
Flow.pm:		? $config->[0]->{mix_to_disk}->{format}
Flow.pm:		: $config->[0]->{mixer_out}->{format}
Flow.pm:# Multi: output 'cooked' monitor channels to side-by-side
Flow.pm:	$debug and print "rec_setup $oids[-1]->{input}\n";
Flow.pm:	map{ $oid_status{$_->{name}} = $_->{default} eq 'on' ? 1 : 0 } @oids;
Flow.pm:sub mono_to_stereo { " -erc:1,2 " }
Flow.pm:	return if ! defined $state_c{$n}->{ch_m} or $state_c{$n}{ch_m} == 1;
Flow.pm:	&route(2,$state_c{$n}->{ch_m}); # stereo signal
Flow.pm:	map{ $_->{input} = q(jack)} grep{ $_->{name} =~ /rec_/ } @oids;	
Flow.pm:	map{ $_->{output} = q(jack)} grep{ $_->{name} =~ /live|multi|stereo/ } @oids;	
Flow.pm:		&eval_iam("cs-remove $session_file");
Flow.pm:		&eval_iam("cs-load ". $session_file);
Flow.pm:		$debug and map{print "$_\n\n"}map{$e->eci($_)} qw(cs es fs st ctrl-status);
Flow.pm:	system qq(killall -9 $ecasound);
Flow.pm:	$e = Audio::Ecasound->new();
Flow.pm:	carp("Invalid chain setup, cannot arm transport.\n"),return unless &eval_iam("cs-is-valid");
Flow.pm:	&eval_iam('cs-connect');
Flow.pm:		unless &eval_iam("engine-status") eq 'not started' ;
Flow.pm:	&eval_iam('engine-launch');
Flow.pm:		unless &eval_iam("engine-status") eq 'stopped' ;
Flow.pm:	$length = &eval_iam('cs-get-length'); 
Flow.pm:	$gui and $setup_length->configure(-text => &colonize($length));
Flow.pm:	&eval_iam("cs-set-length $length") unless @record;
Flow.pm:	$gui and $clock->configure(-text => &colonize(0));
Flow.pm:	carp("Invalid chain setup, aborting start.\n"),return unless &eval_iam("cs-is-valid");
Flow.pm:	$debug2 and print "&stop_transport\n"; $e->eci('stop'); $session_label->configure(-background => $old_bg);
Flow.pm:	 $e->eci('engine-status') eq 'running' ;
Flow.pm:sub disconnect_transport { &eval_iam('cs-disconnect') }
Flow.pm:	$clock_id = $clock->repeat(1000, \&refresh_clock);
Flow.pm:	$clock->configure(-text => &colonize(&eval_iam('cs-get-position')));
Flow.pm:	eval q($clock_id->cancel);
Flow.pm:	$clock->configure(-text => &colonize(&eval_iam('cs-get-position')));
Flow.pm:	my $status = &eval_iam('engine-status');
Flow.pm:	$clock_id->cancel;
Flow.pm:	$session_label->configure(-background => $old_bg);
Flow.pm:		$time_step->configure(-text => 'Min');
Flow.pm:		$time_step->configure(-text => 'Sec');
Flow.pm:	&eval_iam(qq(cs-set-position 0));
Flow.pm:	my $end = &eval_iam(qq(cs-get-length)) - 10 ;  
Flow.pm:	&eval_iam(qq(cs-set-position $end));
Flow.pm:	$new_pos = $new_pos < $length ? $new_pos : $length - 10;
Flow.pm:	$e->eci("setpos $new_pos");
Flow.pm:	my @w = $take_frame->children;
Flow.pm:			$debug and print "t-rec $t\n";	
Flow.pm:			$debug and print "t-mon $t\n";	
Flow.pm:			$debug and print "t-mute $t\n";	
Flow.pm:		$w[$t]->configure(-background => $take_color{$status});
Flow.pm:		$widget_c{$n}->{rw}->configure(-text => $rec_status);
Flow.pm:		$widget_c{$n}->{name}->configure(-background => 'lightpink');
Flow.pm:		$widget_c{$n}->{name}->configure(-foreground => 'Black');
Flow.pm:		$widget_c{$n}->{ch_r}->configure(-background => 'LightPink');
Flow.pm:		$widget_c{$n}->{ch_r}->configure(-foreground => 'Black');
Flow.pm:		$widget_c{$n}->{ch_m}->configure( -background => $old_bg);
Flow.pm:		$widget_c{$n}->{ch_m}->configure( -foreground => 'DarkGray');
Flow.pm:		$widget_c{$n}->{version}->configure(-text => &new_version);
Flow.pm:		 $widget_c{$n}->{name}->configure(-background => 'AntiqueWhite');
Flow.pm:		 $widget_c{$n}->{name}->configure(-foreground => 'Black');
Flow.pm:		 $widget_c{$n}->{ch_r}->configure( -background => $old_bg);
Flow.pm:		 $widget_c{$n}->{ch_r}->configure( -foreground => 'DarkGray');
Flow.pm:		 $widget_c{$n}->{ch_m}->configure( -background => 'AntiqueWhite');
Flow.pm:		 $widget_c{$n}->{ch_m}->configure( -foreground => 'Black');
Flow.pm:		$widget_c{$n}->{version}->configure(-text => &selected_version($n));
Flow.pm:		 $widget_c{$n}->{name}->configure(-background => $old_bg);
Flow.pm:		 $widget_c{$n}->{ch_r}->configure( -background => $old_bg); 
Flow.pm:		 $widget_c{$n}->{ch_r}->configure( -foreground => 'Gray');
Flow.pm:		 $widget_c{$n}->{ch_m}->configure( -background => $old_bg); 
Flow.pm:		$widget_c{$n}->{ch_m}->configure( -foreground => 'Gray');
Flow.pm:		$widget_c{$n}->{version}->configure(-text => &selected_version($n));
Flow.pm:	map{ $widget_o{$_}->configure( # uses hash
Flow.pm:			-background => 
Flow.pm:			-activebackground => 
Flow.pm:## post-recording functions
Flow.pm: 		my ($n) = $outputs{file}{$k}[-1] =~ m/(\d+)/; 
Flow.pm:		if (-e $test_wav) {
Flow.pm:			if (-s $test_wav > 44100) { # 0.5s x 16 bits x 44100/s
Flow.pm:				$state_c{$n}->{active} = $state_c{$n}->{versions}->[-1];
Flow.pm:	if ( ($recorded -  $mixed) >= 1) {
Flow.pm:			$state_t{ $state_t{active} }->{rw} = $::MON;
Flow.pm:	my $w = $widget_c{$n}->{version};
Flow.pm:					$w->radiobutton(
Flow.pm:						-label => $v,
Flow.pm:						-variable => \$state_c{$n}->{active},
Flow.pm:						-value => $v,
Flow.pm:						-command => 
Flow.pm:		sub { $widget_c{$n}->{version}->configure(-text=>$v) 
Flow.pm:				$widget_t[0]->radiobutton(
Flow.pm:						-label => $last_version,
Flow.pm:						-variable => \$monitor_version,
Flow.pm:						-value => $last_version,
Flow.pm:						-command => sub { &mon_vert(eval $last_version) }
Flow.pm:	return if $id eq $state_c{$n}->{vol} or
Flow.pm:	          $id eq $state_c{$n}->{pan};   # skip these effects 
Flow.pm:		my $display_type = $cops{$id}->{display}; # individual setting
Flow.pm:		defined $display_type or $display_type = $effects[$i]->{display}; # template
Flow.pm:				$frame = $widget_c{$n}->{parents}->Frame->pack(
Flow.pm:					-side => 'left', 
Flow.pm:					-anchor => 'nw',)
Flow.pm:				$frame = $widget_c{$n}->{children}->Frame->pack(
Flow.pm:					-side => 'top', 
Flow.pm:					-anchor => 'nw')
Flow.pm:			my $parentage = $effects[ $effect_i{ $cops{$parent_id}->{type}} ]
Flow.pm:				->{name};
Flow.pm:			$parentage and $parentage .=  " - ";
Flow.pm:			my $eff = $frame->Menubutton(
Flow.pm:				-text => $parentage. $effects[$i]->{name}, -tearoff => 0,);
Flow.pm:			$eff->AddItems([
Flow.pm:				-command => sub {&remove_effect($id) }
Flow.pm:			$eff->grid();
Flow.pm:			for my $p (0..$effects[$i]->{count} - 1 ) {
Flow.pm:					[ 'command' => $effects[$j]->{name},
Flow.pm:						-command => sub { &add_effect ({
Flow.pm:								type => $effects[$j]->{code} } )  }
Flow.pm:			push @labels, $frame->Menubutton(
Flow.pm:					-text => $effects[$i]->{params}->[$p]->{name},
Flow.pm:					-menuitems => [@items],
Flow.pm:					-tearoff => 0,
Flow.pm:					$effects[$i]->{params}->[$p]->{name},"\n";
Flow.pm:				$sliders[0]->grid(@sliders[1..$#sliders]);
Flow.pm:				 $labels[0]->grid(@labels[1..$#labels]);
Flow.pm:	&apply_op($id) if &eval_iam("cs-is-valid");
Flow.pm:	my $n = $cops{$id}->{chain};
Flow.pm:	if ( my $parent = $cops{$id}->{belongs_to} ) {
Flow.pm:		@{ $cops{$parent}->{owns} }, "\n";
Flow.pm:		@{ $cops{$parent}->{owns} }  =  grep{ $_ ne $id}
Flow.pm:		@{ $cops{$parent}->{owns} } ; 
Flow.pm:	$debug and print "children found: ", join "|",@{$cops{$id}->{owns}},"\n";
Flow.pm:	map{&remove_effect($_)}@{ $cops{$id}->{owns} };
Flow.pm:	&remove_op($id) unless $cops{$id}->{belongs_to};
Flow.pm:	$state_c{$n}->{ops} = 
Flow.pm:		[ grep{ $_ ne $id} @{ $state_c{ $cops{$id}->{chain} }->{ops} } ];
Flow.pm:	$widget_e{$id}->destroy();
Flow.pm:	my $n = $cops{$id}->{chain};
Flow.pm:	if ( $cops{$id}->{belongs_to}) { 
Flow.pm:	$debug and print "ops list for chain $n: @{$state_c{$n}->{ops}}\n";
Flow.pm:		for my $pos ( 0.. scalar @{ $state_c{$n}->{ops} } - 1  ) {
Flow.pm:			($index = $pos), last if $state_c{$n}->{ops}->[$pos] eq $id;
Flow.pm:	 &eval_iam ("c-select $n");
Flow.pm:	&eval_iam ("cop-select ". ($state_c{$n}->{offset} + $index));
Flow.pm:	&eval_iam ("cop-remove");
Flow.pm:	# make entry in %cops with chain, code, display-type, children
Flow.pm:					  display => $effects[$i]->{display},
Flow.pm:		$debug and print "parent owns" , join " ",@{ $cops{$parent_id}->{owns}}, "\n";
Flow.pm:		push @{ $cops{$parent_id}->{owns}}, $cop_id;
Flow.pm:		$cops{$cop_id}->{belongs_to} = $parent_id;
Flow.pm:		$copp{$cop_id}->[0] = $parameter + 1; # set fx-param to the parameter number.
Flow.pm: 		my $end = scalar @{ $state_c{$n}->{ops} } - 1 ; 
Flow.pm: 			splice ( @{$state_c{$n}->{ops}}, $i+1, 0, $cop_id ), last
Flow.pm: 				if $state_c{$n}->{ops}->[$i] eq $parent_id
Flow.pm:	else { push @{$state_c{$n}->{ops} }, $cop_id; }
Flow.pm:		my $i = $effect_i{ $cops{$id}->{type} };
Flow.pm:		#for my $p ($parent_id ? 1 : 0..$effects[$i]->{count} - 1) {
Flow.pm:		# XXX support controller-type operators
Flow.pm:		for my $p (0..$effects[$i]->{count} - 1) {
Flow.pm:			my $default = $effects[$i]->{params}->[$p]->{default};
Flow.pm:	return if ! defined $state_c{$chain}->{offset}; # MIX
Flow.pm:	$debug and print "valid: ", &eval_iam("cs-is-valid"), "\n";
Flow.pm:	for my $op (0..scalar @{ $state_c{$chain}->{ops} } - 1) {
Flow.pm:		${ $state_c{$chain}->{ops} } [$op] eq $id and $controller = $op 
Flow.pm:	$debug and print "cop_id $id corresponds to track: $chain, controller: $controller, offset: $state_c{$chain}->{offset}\n";
Flow.pm:	&eval_iam ("c-select $chain");
Flow.pm:	&eval_iam ("cop-select ". ($state_c{$chain}->{offset} + $controller));
Flow.pm:	&eval_iam ("copp-select $param");
Flow.pm:	&eval_iam ("copp-set $val");
Flow.pm:	If reverb is added and it is the first user-added effect, the offset will
Flow.pm:	will also be the offset needed for our start-at-zero array. 
Flow.pm:	&eval_iam('c-select-all');
Flow.pm:			next if $chain_id =~ m/\D/; # skip id's containing non-digits
Flow.pm:			$state_c{$chain_id}->{offset} = ($quotes/2 - 1) + 1; 
Flow.pm:	$debug and print "chain: $n, offset: $state_c{$n}->{offset}\n";
Flow.pm:		next if ! defined $state_c{$n}->{offset}; # for MIX
Flow.pm: 		next if ! $state_c{$n}->{offset} ;
Flow.pm:		for my $id ( @{ $state_c{$n}->{ops} } ) {
Flow.pm:		#	next if $cops{$id}->{belongs_to}; 
Flow.pm:	my $code = $cops{$id}->{type};
Flow.pm:	$debug and print "chain: $cops{$id}->{chain} type: $cops{$id}->{type}, code: $code\n";
Flow.pm:	$code = '-' . $code . ($code =~ /:/ ? q(,) : q(:) );
Flow.pm:	my $add = "cop-add "; 
Flow.pm:	# if my parent has a parent then we need to append the -kx  operator
Flow.pm:	my $dad = $cops{$id}->{belongs_to};
Flow.pm:	$add .= " -kx" if $cops{$dad}->{belongs_to};
Flow.pm:	&eval_iam ("c-select $cops{$id}->{chain}") 
Flow.pm:		unless $cops{$id}->{belongs_to}; # avoid reset
Flow.pm:	$debug and print "children found: ", join ",", "|",@{$cops{$id}->{owns}},"|\n";
Flow.pm:	map{&apply_op($_)} @{ $cops{$id}->{owns} };
Flow.pm:	# TODO re-read effects data if ladspa or user presets are
Flow.pm:	if (-f $effects_cache and ! $opts{e}){ 
Flow.pm:	carp ("incorrect number of lines ", join ' ',$upper-$lower,scalar @lines)
Flow.pm:		if $lower + @lines - 1 != $upper;
Flow.pm:		$effects[$j]->{number} = $no;
Flow.pm:		$effects[$j]->{code} = $id;
Flow.pm:		$effects[$j]->{name} = $name;
Flow.pm:		$effects[$j]->{count} = scalar @p_names;
Flow.pm:		$effects[$j]->{params} = [];
Flow.pm:		$effects[$j]->{display} = qq(field);
Flow.pm:		map{ push @{$effects[$j]->{params}}, {name => $_} } @p_names;
Flow.pm:	map{push @ladspa_sorted, 0} ( 1 .. $aa ); # fills array slice [0..$aa-1]
Flow.pm:		 sort { $effects[$a]->{name} cmp $effects[$b]->{name} } ($aa .. $zz) ;
Flow.pm:	my @ladspa = grep {! /^\w*$/ } split "\n", &eval_iam("ladspa-register");
Flow.pm:	my @preset = grep {! /^\w*$/ } split "\n", &eval_iam("preset-register");
Flow.pm:	my @ctrl  = grep {! /^\w*$/ } split "\n", &eval_iam("ctrl-register");
Flow.pm:		-(pn:\w+)    # preset_id 
Flow.pm:		(\w.+?) # name, starting with word-char,  non-greedy
Flow.pm:		-(el:\w+),? # ladspa_id maybe followed by comma
Flow.pm:		(\w.+?) # name, starting with word-char,  non-greedy
Flow.pm:		-(k\w+):?    # ktrl_id maybe followed by colon
Flow.pm:		 $effect_i{ $effects[$i]->{code} } = $i; 
Flow.pm:		 $debug and print "i: $i code: $effects[$i]->{code} display: $effects[$i]->{display}\n";
Flow.pm:		$effects[$i]->{display} = qq(scale);
Flow.pm:	#print "effects code: $i stands for ", $effects[$i]->{code}, "\n";
Flow.pm:	#print "count: $effects[$i]->{count}\n";
Flow.pm:			for (1..$effects[$i]->{count}){
Flow.pm:				push @{$effects[$i]->{params}}, \%p;
Flow.pm:	# | perl -ne 'chomp; s/$ENV{LADSPA_PATH}//; system qq(analyseplugin $_)'
Flow.pm:	my $ladspa_sample_rate = 44100; # for sample-rate dependent effect
Flow.pm:		$effects_ladspa {$plugin_label}->{params} = [ @params ];
Flow.pm:		$effects_ladspa {$plugin_label}->{count} = scalar @params;
Flow.pm:		$effects_ladspa {$plugin_label}->{display} = 'scale';
Flow.pm:	my $resolution = ($end - $beg) / 100;
Flow.pm:		$resolution = ($end - $beg) / 100;
Flow.pm:		$effects[$i]->{params} = $effects_ladspa{$_}->{params};
Flow.pm:		$effects[$i]->{display} = $effects_ladspa{$_}->{display};
Flow.pm:print '-' x 60, "\n";
Flow.pm: ls $LADSPA_PATH | perl -ne 'chomp; s/$ENV{LADSPA_PATH}//; system qq(analyseplugin $_)'
Flow.pm:Must Run Real-Time: No
Flow.pm:Environment: Normal or Hard Real-Time
Flow.pm:	map{ $copp{ $state_c{$_}{vol} }->[0] = $old_vol{$_} ;
Flow.pm:	my $result2 = system "alsactl -f $file.alsa store";
Flow.pm:	map{ $copp{ $state_c{$_}{vol} }->[0] = 0} 
Flow.pm:	my $result = system "sudo alsactl -f $file.alsa restore";
Flow.pm:	map{ $time_marks[$_]->configure( 
Flow.pm:		-text => &colonize($marks[$_]),
Flow.pm:		-background => $old_bg,
Flow.pm:		for my $id (@{$state_c{$n}->{ops}}){
Flow.pm:				unless $id eq $state_c{$n}->{vol}
Flow.pm:					or $id eq $state_c{$n}->{pan};
Flow.pm:						chain => $cops{$id}->{chain},
Flow.pm:						type => $cops{$id}->{type},
Flow.pm:						parent_id => $cops{$id}->{belongs_to},
Flow.pm:		# a parameter controller, and therefore need the -kx switch
Flow.pm:	$did_apply and $gui and $ew->deiconify();
Flow.pm:	map  {$copp{ $state_c{$_}{vol} }->[0] = $old_vol{$_} ;
Flow.pm:	map{ 	$state_c_ops{$_} = $state_c{$_}->{ops} } @all_chains;
Flow.pm:	# map {&remove_op} @{ $state_c{$_}->{ops} }
Flow.pm:	map{ $time_marks[$_]->configure( 
Flow.pm:		-text => $marks[$_]
Flow.pm:		-background => $marks[$_]
Flow.pm:		@{ $state_c{$_}->{ops} }, "\n";
Flow.pm:				if (	$state_c{$n}->{vol} eq $id or
Flow.pm:						$state_c{$n}->{pan} eq $id  ){
Flow.pm:		} @{ $state_c{$_}->{ops} }
Flow.pm:	map{ $state_c{$_}->{ops} = $state_c_ops{$_} } @all_chains;
Flow.pm:	# restore ops->chain mapping
Flow.pm:				if (	$state_c{$n}->{vol} eq $id or
Flow.pm:						$state_c{$n}->{pan} eq $id  ){
Flow.pm:					$copp{$id}->[0] = $old_copp{$id}->[0];
Flow.pm:			} @{ $state_c{$_}->{ops} }
Flow.pm:		for my $id (@{$state_c{$n}->{ops}}){
Flow.pm:				unless $id eq $state_c{$n}->{vol}
Flow.pm:					or $id eq $state_c{$n}->{pan};
Flow.pm:						chain => $cops{$id}->{chain},
Flow.pm:						type => $cops{$id}->{type},
Flow.pm:						parent_id => $cops{$id}->{belongs_to},
Flow.pm:		# a parameter controller, and therefore need the -kx switch
Flow.pm:	# $ew->deiconify or $ew->iconify;
Flow.pm:	-f $file or carp ("file: $file not found\n"),return 0;
Flow.pm:						. q({ $hash_ref->{)
Flow.pm:						. q(} } if defined $hash_ref->{)
Flow.pm:    my $yw = Data::YAML::Writer->new;
Flow.pm:    $yw->write( \%state, \$yamlout );
Flow.pm:    my $yr = Data::YAML::Reader->new;
Flow.pm:    my $from_array = $yr->read( \@some_array );
Flow.pm:    my $from_handle = $yr->read( $some_file );
Flow.pm:    my $from_string = $yr->read( $some_string );
Flow.pm:    my $from_code = $yr->read( sub { return get_next_line() } );
Flow.pm:    my $yw = Data::YAML::Writer->new;
Flow.pm:    $yw->write( $data, \@some_array );
Flow.pm:    $yw->write( $data, $some_file_handle );
Flow.pm:    $yw->write( $data, \$some_string );
Flow.pm:    $yw->write( $data, sub {
Flow.pm:		map{$time_marks[$_]->configure( -background => $old_bg) unless ! $marks[$_] } 1..$#time_marks ;
Flow.pm:		map{$_->configure( -background => 'lightblue') } @time_marks[1..$#time_marks] ;
Flow.pm:		my $here = &eval_iam("cs-get-position");
Flow.pm:		$widget->configure(
Flow.pm:			-text => &colonize($here),
Flow.pm:			-background => $old_bg,
Flow.pm:		&eval_iam(qq(cs-set-position $marks[$marker]));
Flow.pm:Audio::Ecasound::Flow - Perl extensions for multitrack audio
Flow.pm:  my $ui = Audio::Ecasound::Flow::GUI->new("Tk");
Flow.pm:  my $ui = Audio::Ecasound::Flow::GUI->new("text");
Flow.pm:			effects => 'force-reload',
Flow.pm:	$ui->main(%options);
Flow.pm:Joel Roth, E<lt>jroth@dsl-verizon.netE<gt>
Init.pm:use lib '/home/jroth/ecmd-dev';
Init.pm:use lib '/home/jroth/ecmd-dev/Audio';
Init.pm:use lib '/home/jroth/ecmd-dev/Audio/Ecasound/Flow';
Init.pm:$ladspa_sample_rate = 44100; # for sample-rate dependent effect
Init.pm:# for sample-rate dependent LADSPA effect parameters, ideally 
Init.pm:# should change with per-project sample rates in parameters.pl
Init.pm:$unit  = 1; # fast-forward multiplier default;
Makefile:#     AUTHOR => q[Joel Roth <jroth@dsl-verizon.net>]
Makefile:# --- MakeMaker post_initialize section:
Makefile:# --- MakeMaker const_config section:
Makefile:# These definitions are from config.sh (via /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/Config.pm)
Makefile:CCCDLFLAGS = -fpic
Makefile:CCDLFLAGS = -rdynamic
Makefile:LDDLFLAGS = -shared -L/usr/local/lib
Makefile:LDFLAGS =  -L/usr/local/lib
Makefile:LIBC = /lib/libc-2.3.1.so
Makefile:OSVERS = 2.4.21-rc7
Makefile:# --- MakeMaker constants section:
Makefile:DISTNAME = Audio-Ecasound-Flow
Makefile:INSTALLARCHLIB = /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi
Makefile:INSTALLSITEARCH = /usr/local/lib/perl5/site_perl/5.8.0/i686-linux-thread-multi
Makefile:PERL_ARCHLIB = /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi
Makefile:SITEARCHEXP = /usr/local/lib/perl5/site_perl/5.8.0/i686-linux-thread-multi
Makefile:PERL_INC = /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE
Makefile:PERLRUNINST = $(PERLRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"
Makefile:FULLPERLRUNINST = $(FULLPERLRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"
Makefile:ABSPERLRUNINST = $(ABSPERLRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"
Makefile:NOOP = $(SHELL) -c true
Makefile:DEFINE_VERSION = -D$(VERSION_MACRO)=\"$(VERSION)\"
Makefile:XS_DEFINE_VERSION = -D$(XS_VERSION_MACRO)=\"$(XS_VERSION)\"
Makefile:PERL_MALLOC_DEF = -DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc -Dfree=Perl_mfree -Drealloc=Perl_realloc -Dcalloc=Perl_calloc
Makefile:# work around a famous dec-osf make(1) feature(?):
Makefile:# --- MakeMaker tool_autosplit section:
Makefile:AUTOSPLITFILE = $(PERLRUN) -e 'use AutoSplit;  autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1) ;'
Makefile:# --- MakeMaker tool_xsubpp section:
Makefile:# --- MakeMaker tools_other section:
Makefile:NOOP = $(SHELL) -c true
Makefile:RM_F = rm -f
Makefile:RM_RF = rm -rf
Makefile:TEST_F = test -f
Makefile:# The following is a portable way to say mkdir -p
Makefile:MKPATH = $(PERLRUN) "-MExtUtils::Command" -e mkpath
Makefile:EQUALIZE_TIMESTAMP = $(PERLRUN) "-MExtUtils::Command" -e eqtime
Makefile:WARN_IF_OLD_PACKLIST = $(PERL) -we 'exit unless -f $$ARGV[0];' \
Makefile:-e 'print "WARNING: I have found an old package in\n";' \
Makefile:-e 'print "\t$$ARGV[0].\n";' \
Makefile:-e 'print "Please make sure the two installations are not conflicting\n";'
Makefile:MOD_INSTALL = $(PERL) "-I$(INST_LIB)" "-I$(PERL_LIB)" "-MExtUtils::Install" \
Makefile:-e "install({@ARGV},'$(VERBINST)',0,'$(UNINST)');"
Makefile:DOC_INSTALL = $(PERL) -e '$$\="\n\n";' \
Makefile:-e 'print "=head2 ", scalar(localtime), ": C<", shift, ">", " L<", $$arg=shift, "|", $$arg, ">";' \
Makefile:-e 'print "=over 4";' \
Makefile:-e 'while (defined($$key = shift) and defined($$val = shift)){print "=item *";print "C<$$key: $$val>";}' \
Makefile:-e 'print "=back";'
Makefile:UNINSTALL =   $(PERLRUN) "-MExtUtils::Install" \
Makefile:-e 'uninstall($$ARGV[0],1,1); print "\nUninstall is deprecated. Please check the";' \
Makefile:-e 'print " packlist above carefully.\n  There may be errors. Remove the";' \
Makefile:-e 'print " appropriate files manually.\n  Sorry for the inconveniences.\n"'
Makefile:# --- MakeMaker dist section:
Makefile:ZIPFLAGS = -r
Makefile:CI = ci -u
Makefile:COMPRESS = gzip --best
Makefile:DISTVNAME = $(DISTNAME)-$(VERSION)
Makefile:RCS_LABEL = rcs -Nv$(VERSION_SYM): -q
Makefile:# --- MakeMaker macro section:
Makefile:# --- MakeMaker depend section:
Makefile:# --- MakeMaker cflags section:
Makefile:# --- MakeMaker const_loadlibs section:
Makefile:# --- MakeMaker const_cccmd section:
Makefile:# --- MakeMaker post_constants section:
Makefile:# --- MakeMaker pasthru section:
Makefile:# --- MakeMaker c_o section:
Makefile:# --- MakeMaker xs_c section:
Makefile:# --- MakeMaker xs_o section:
Makefile:# --- MakeMaker top_targets section:
Makefile:$(INST_AUTODIR)/.exists :: /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h
Makefile:	@$(EQUALIZE_TIMESTAMP) /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h $(INST_AUTODIR)/.exists
Makefile:	-@$(CHMOD) $(PERM_RWX) $(INST_AUTODIR)
Makefile:$(INST_LIBDIR)/.exists :: /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h
Makefile:	@$(EQUALIZE_TIMESTAMP) /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h $(INST_LIBDIR)/.exists
Makefile:	-@$(CHMOD) $(PERM_RWX) $(INST_LIBDIR)
Makefile:$(INST_ARCHAUTODIR)/.exists :: /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h
Makefile:	@$(EQUALIZE_TIMESTAMP) /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h $(INST_ARCHAUTODIR)/.exists
Makefile:	-@$(CHMOD) $(PERM_RWX) $(INST_ARCHAUTODIR)
Makefile:$(INST_MAN3DIR)/.exists :: /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h
Makefile:	@$(EQUALIZE_TIMESTAMP) /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h $(INST_MAN3DIR)/.exists
Makefile:	-@$(CHMOD) $(PERM_RWX) $(INST_MAN3DIR)
Makefile:# --- MakeMaker linkext section:
Makefile:# --- MakeMaker dlsyms section:
Makefile:# --- MakeMaker dynamic section:
Makefile:# --- MakeMaker dynamic_bs section:
Makefile:# --- MakeMaker dynamic_lib section:
Makefile:# --- MakeMaker static section:
Makefile:# --- MakeMaker static_lib section:
Makefile:# --- MakeMaker manifypods section:
Makefile:POD2MAN = $(PERL) -we '%m=@ARGV;for (keys %m){' \
Makefile:-e 'next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M "Makefile";' \
Makefile:-e 'print "Manifying $$m{$$_}\n";' \
Makefile:-e 'system(q[$(PERLRUN) $(POD2MAN_EXE) ].qq[$$_>$$m{$$_}])==0 or warn "Couldn\047t install $$m{$$_}\n";' \
Makefile:-e 'chmod(oct($(PERM_RW)), $$m{$$_}) or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'
Makefile:# --- MakeMaker processPL section:
Makefile:# --- MakeMaker installbin section:
Makefile:# --- MakeMaker subdirs section:
Makefile:# --- MakeMaker clean section:
Makefile:	-rm -rf ./blib $(MAKE_APERL_FILE) $(INST_ARCHAUTODIR)/extralibs.all perlmain.c tmon.out mon.out so_locations pm_to_blib *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT) $(BOOTSTRAP) $(BASEEXT).bso $(BASEEXT).def lib$(BASEEXT).def $(BASEEXT).exp $(BASEEXT).x core core.*perl.*.? *perl.core
Makefile:	-mv Makefile Makefile.old $(DEV_NULL)
Makefile:# --- MakeMaker realclean section:
Makefile:	rm -rf $(INST_AUTODIR) $(INST_ARCHAUTODIR)
Makefile:	rm -rf $(DISTVNAME)
Makefile:	rm -f  blib/lib/Audio/Ecasound/ecmd.pl blib/lib/Audio/Ecasound/UI.pm
Makefile:	rm -f blib/lib/Audio/Ecasound/Config.pm blib/lib/Audio/Ecasound/Grammar.pm
Makefile:	rm -f blib/lib/Audio/Ecasound/Iam.pm blib/lib/Audio/Ecasound/Flow.pm
Makefile:	rm -rf Makefile Makefile.old
Makefile:# --- MakeMaker dist_basics section:
Makefile:	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
Makefile:	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
Makefile:	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
Makefile:# --- MakeMaker dist_core section:
Makefile:	@$(PERL) -le 'print "Warning: Makefile possibly out of date with $$vf" if ' \
Makefile:	    -e '-e ($$vf="$(VERSION_FROM)") and -M $$vf < -M "Makefile";'
Makefile:# --- MakeMaker dist_dir section:
Makefile:	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
Makefile:		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
Makefile:# --- MakeMaker dist_test section:
Makefile:# --- MakeMaker dist_ci section:
Makefile:	$(PERLRUN) "-MExtUtils::Manifest=maniread" \
Makefile:		-e "@all = keys %{ maniread() };" \
Makefile:		-e 'print("Executing $(CI) @all\n"); system("$(CI) @all");' \
Makefile:		-e 'print("Executing $(RCS_LABEL) ...\n"); system("$(RCS_LABEL) @all");'
Makefile:# --- MakeMaker install section:
Makefile:	-@$(MKPATH) $(INSTALLARCHLIB)
Makefile:	-@$(DOC_INSTALL) \
Makefile:	-@$(MKPATH) $(INSTALLARCHLIB)
Makefile:	-@$(DOC_INSTALL) \
Makefile:# --- MakeMaker force section:
Makefile:# --- MakeMaker perldepend section:
Makefile:# --- MakeMaker makefile section:
Makefile:	@echo "Makefile out-of-date with respect to $?"
Makefile:	-@$(RM_F) Makefile.old
Makefile:	-@$(MV) Makefile Makefile.old
Makefile:	-$(MAKE) -f Makefile.old clean $(DEV_NULL) || $(NOOP)
Makefile:# --- MakeMaker staticmake section:
Makefile:# --- MakeMaker makeaperl section ---
Makefile:	$(MAKE) -f $(MAKE_APERL_FILE) $@
Makefile:# --- MakeMaker test section:
Makefile:TESTDB_SW = -d
Makefile:	PERL_DL_NONLAZY=1 $(FULLPERLRUN) "-MExtUtils::Command::MM" "-e" "test_harness($(TEST_VERBOSE), '$(INST_LIB)', '$(INST_ARCHLIB)')" $(TEST_FILES)
Makefile:	PERL_DL_NONLAZY=1 $(FULLPERLRUN) "-I$(INST_LIB)" "-I$(INST_ARCHLIB)" $(TEST_FILE)
Makefile:	PERL_DL_NONLAZY=1 $(FULLPERLRUN) $(TESTDB_SW) "-I$(INST_LIB)" "-I$(INST_ARCHLIB)" $(TEST_FILE)
Makefile:# --- MakeMaker ppd section:
Makefile:	@$(PERL) -e "print qq{<SOFTPKG NAME=\"$(DISTNAME)\" VERSION=\"0,01,0,0\">\n\t<TITLE>$(DISTNAME)</TITLE>\n\t<ABSTRACT>Perl extensions for multitrack audio</ABSTRACT>\n\t<AUTHOR>Joel Roth &lt;jroth\@dsl-verizon.net&gt;</AUTHOR>\n}" > $(DISTNAME).ppd
Makefile:	@$(PERL) -e "print qq{\t<IMPLEMENTATION>\n}" >> $(DISTNAME).ppd
Makefile:	@$(PERL) -e "print qq{\t\t<OS NAME=\"$(OSNAME)\" />\n\t\t<ARCHITECTURE NAME=\"i686-linux-thread-multi\" />\n\t\t<CODEBASE HREF=\"\" />\n\t</IMPLEMENTATION>\n</SOFTPKG>\n}" >> $(DISTNAME).ppd
Makefile:# --- MakeMaker pm_to_blib section:
Makefile:	@$(PERLRUNINST) "-MExtUtils::Install" \
Makefile:	-e "pm_to_blib({qw{ecmd.pl blib/lib/Audio/Ecasound/ecmd.pl UI.pm blib/lib/Audio/Ecasound/UI.pm Grammar.pm blib/lib/Audio/Ecasound/Grammar.pm Config.pm blib/lib/Audio/Ecasound/Config.pm Iam.pm blib/lib/Audio/Ecasound/Iam.pm}},'$(INST_LIB)/auto','$(PM_FILTER)')"
Makefile:	@$(PERLRUNINST) "-MExtUtils::Install" \
Makefile:	-e "pm_to_blib({qw{Flow.pm blib/lib/Audio/Ecasound/Flow.pm}},'$(INST_LIB)/auto','$(PM_FILTER)')"
Makefile:# --- MakeMaker selfdocument section:
Makefile:# --- MakeMaker postamble section:
Makefile.PL:       AUTHOR     => 'Joel Roth <jroth@dsl-verizon.net>') : ()),
Makefile.old:#     AUTHOR => q[Joel Roth <jroth@dsl-verizon.net>]
Makefile.old:# --- MakeMaker post_initialize section:
Makefile.old:# --- MakeMaker const_config section:
Makefile.old:# These definitions are from config.sh (via /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/Config.pm)
Makefile.old:CCCDLFLAGS = -fpic
Makefile.old:CCDLFLAGS = -rdynamic
Makefile.old:LDDLFLAGS = -shared -L/usr/local/lib
Makefile.old:LDFLAGS =  -L/usr/local/lib
Makefile.old:LIBC = /lib/libc-2.3.1.so
Makefile.old:OSVERS = 2.4.21-rc7
Makefile.old:# --- MakeMaker constants section:
Makefile.old:DISTNAME = Audio-Ecasound-Flow
Makefile.old:INSTALLARCHLIB = /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi
Makefile.old:INSTALLSITEARCH = /usr/local/lib/perl5/site_perl/5.8.0/i686-linux-thread-multi
Makefile.old:PERL_ARCHLIB = /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi
Makefile.old:SITEARCHEXP = /usr/local/lib/perl5/site_perl/5.8.0/i686-linux-thread-multi
Makefile.old:PERL_INC = /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE
Makefile.old:PERLRUNINST = $(PERLRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"
Makefile.old:FULLPERLRUNINST = $(FULLPERLRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"
Makefile.old:ABSPERLRUNINST = $(ABSPERLRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"
Makefile.old:NOOP = $(SHELL) -c true
Makefile.old:DEFINE_VERSION = -D$(VERSION_MACRO)=\"$(VERSION)\"
Makefile.old:XS_DEFINE_VERSION = -D$(XS_VERSION_MACRO)=\"$(XS_VERSION)\"
Makefile.old:PERL_MALLOC_DEF = -DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc -Dfree=Perl_mfree -Drealloc=Perl_realloc -Dcalloc=Perl_calloc
Makefile.old:# work around a famous dec-osf make(1) feature(?):
Makefile.old:# --- MakeMaker tool_autosplit section:
Makefile.old:AUTOSPLITFILE = $(PERLRUN) -e 'use AutoSplit;  autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1) ;'
Makefile.old:# --- MakeMaker tool_xsubpp section:
Makefile.old:# --- MakeMaker tools_other section:
Makefile.old:NOOP = $(SHELL) -c true
Makefile.old:RM_F = rm -f
Makefile.old:RM_RF = rm -rf
Makefile.old:TEST_F = test -f
Makefile.old:# The following is a portable way to say mkdir -p
Makefile.old:MKPATH = $(PERLRUN) "-MExtUtils::Command" -e mkpath
Makefile.old:EQUALIZE_TIMESTAMP = $(PERLRUN) "-MExtUtils::Command" -e eqtime
Makefile.old:WARN_IF_OLD_PACKLIST = $(PERL) -we 'exit unless -f $$ARGV[0];' \
Makefile.old:-e 'print "WARNING: I have found an old package in\n";' \
Makefile.old:-e 'print "\t$$ARGV[0].\n";' \
Makefile.old:-e 'print "Please make sure the two installations are not conflicting\n";'
Makefile.old:MOD_INSTALL = $(PERL) "-I$(INST_LIB)" "-I$(PERL_LIB)" "-MExtUtils::Install" \
Makefile.old:-e "install({@ARGV},'$(VERBINST)',0,'$(UNINST)');"
Makefile.old:DOC_INSTALL = $(PERL) -e '$$\="\n\n";' \
Makefile.old:-e 'print "=head2 ", scalar(localtime), ": C<", shift, ">", " L<", $$arg=shift, "|", $$arg, ">";' \
Makefile.old:-e 'print "=over 4";' \
Makefile.old:-e 'while (defined($$key = shift) and defined($$val = shift)){print "=item *";print "C<$$key: $$val>";}' \
Makefile.old:-e 'print "=back";'
Makefile.old:UNINSTALL =   $(PERLRUN) "-MExtUtils::Install" \
Makefile.old:-e 'uninstall($$ARGV[0],1,1); print "\nUninstall is deprecated. Please check the";' \
Makefile.old:-e 'print " packlist above carefully.\n  There may be errors. Remove the";' \
Makefile.old:-e 'print " appropriate files manually.\n  Sorry for the inconveniences.\n"'
Makefile.old:# --- MakeMaker dist section:
Makefile.old:ZIPFLAGS = -r
Makefile.old:CI = ci -u
Makefile.old:COMPRESS = gzip --best
Makefile.old:DISTVNAME = $(DISTNAME)-$(VERSION)
Makefile.old:RCS_LABEL = rcs -Nv$(VERSION_SYM): -q
Makefile.old:# --- MakeMaker macro section:
Makefile.old:# --- MakeMaker depend section:
Makefile.old:# --- MakeMaker cflags section:
Makefile.old:# --- MakeMaker const_loadlibs section:
Makefile.old:# --- MakeMaker const_cccmd section:
Makefile.old:# --- MakeMaker post_constants section:
Makefile.old:# --- MakeMaker pasthru section:
Makefile.old:# --- MakeMaker c_o section:
Makefile.old:# --- MakeMaker xs_c section:
Makefile.old:# --- MakeMaker xs_o section:
Makefile.old:# --- MakeMaker top_targets section:
Makefile.old:$(INST_AUTODIR)/.exists :: /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h
Makefile.old:	@$(EQUALIZE_TIMESTAMP) /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h $(INST_AUTODIR)/.exists
Makefile.old:	-@$(CHMOD) $(PERM_RWX) $(INST_AUTODIR)
Makefile.old:$(INST_LIBDIR)/.exists :: /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h
Makefile.old:	@$(EQUALIZE_TIMESTAMP) /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h $(INST_LIBDIR)/.exists
Makefile.old:	-@$(CHMOD) $(PERM_RWX) $(INST_LIBDIR)
Makefile.old:$(INST_ARCHAUTODIR)/.exists :: /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h
Makefile.old:	@$(EQUALIZE_TIMESTAMP) /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h $(INST_ARCHAUTODIR)/.exists
Makefile.old:	-@$(CHMOD) $(PERM_RWX) $(INST_ARCHAUTODIR)
Makefile.old:$(INST_MAN3DIR)/.exists :: /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h
Makefile.old:	@$(EQUALIZE_TIMESTAMP) /usr/local/lib/perl5/5.8.0/i686-linux-thread-multi/CORE/perl.h $(INST_MAN3DIR)/.exists
Makefile.old:	-@$(CHMOD) $(PERM_RWX) $(INST_MAN3DIR)
Makefile.old:# --- MakeMaker linkext section:
Makefile.old:# --- MakeMaker dlsyms section:
Makefile.old:# --- MakeMaker dynamic section:
Makefile.old:# --- MakeMaker dynamic_bs section:
Makefile.old:# --- MakeMaker dynamic_lib section:
Makefile.old:# --- MakeMaker static section:
Makefile.old:# --- MakeMaker static_lib section:
Makefile.old:# --- MakeMaker manifypods section:
Makefile.old:POD2MAN = $(PERL) -we '%m=@ARGV;for (keys %m){' \
Makefile.old:-e 'next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M "Makefile";' \
Makefile.old:-e 'print "Manifying $$m{$$_}\n";' \
Makefile.old:-e 'system(q[$(PERLRUN) $(POD2MAN_EXE) ].qq[$$_>$$m{$$_}])==0 or warn "Couldn\047t install $$m{$$_}\n";' \
Makefile.old:-e 'chmod(oct($(PERM_RW)), $$m{$$_}) or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'
Makefile.old:# --- MakeMaker processPL section:
Makefile.old:# --- MakeMaker installbin section:
Makefile.old:# --- MakeMaker subdirs section:
Makefile.old:# --- MakeMaker clean section:
Makefile.old:	-rm -rf ./blib $(MAKE_APERL_FILE) $(INST_ARCHAUTODIR)/extralibs.all perlmain.c tmon.out mon.out so_locations pm_to_blib *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT) $(BOOTSTRAP) $(BASEEXT).bso $(BASEEXT).def lib$(BASEEXT).def $(BASEEXT).exp $(BASEEXT).x core core.*perl.*.? *perl.core
Makefile.old:	-mv Makefile Makefile.old $(DEV_NULL)
Makefile.old:# --- MakeMaker realclean section:
Makefile.old:	rm -rf $(INST_AUTODIR) $(INST_ARCHAUTODIR)
Makefile.old:	rm -rf $(DISTVNAME)
Makefile.old:	rm -f  blib/lib/Audio/Ecasound/ecmd.pl blib/lib/Audio/Ecasound/UI.pm
Makefile.old:	rm -f blib/lib/Audio/Ecasound/Config.pm blib/lib/Audio/Ecasound/Grammar.pm
Makefile.old:	rm -f blib/lib/Audio/Ecasound/Iam.pm blib/lib/Audio/Ecasound/Flow.pm
Makefile.old:	rm -rf Makefile Makefile.old
Makefile.old:# --- MakeMaker dist_basics section:
Makefile.old:	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
Makefile.old:	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
Makefile.old:	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
Makefile.old:# --- MakeMaker dist_core section:
Makefile.old:	@$(PERL) -le 'print "Warning: Makefile possibly out of date with $$vf" if ' \
Makefile.old:	    -e '-e ($$vf="$(VERSION_FROM)") and -M $$vf < -M "Makefile";'
Makefile.old:# --- MakeMaker dist_dir section:
Makefile.old:	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
Makefile.old:		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
Makefile.old:# --- MakeMaker dist_test section:
Makefile.old:# --- MakeMaker dist_ci section:
Makefile.old:	$(PERLRUN) "-MExtUtils::Manifest=maniread" \
Makefile.old:		-e "@all = keys %{ maniread() };" \
Makefile.old:		-e 'print("Executing $(CI) @all\n"); system("$(CI) @all");' \
Makefile.old:		-e 'print("Executing $(RCS_LABEL) ...\n"); system("$(RCS_LABEL) @all");'
Makefile.old:# --- MakeMaker install section:
Makefile.old:	-@$(MKPATH) $(INSTALLARCHLIB)
Makefile.old:	-@$(DOC_INSTALL) \
Makefile.old:	-@$(MKPATH) $(INSTALLARCHLIB)
Makefile.old:	-@$(DOC_INSTALL) \
Makefile.old:# --- MakeMaker force section:
Makefile.old:# --- MakeMaker perldepend section:
Makefile.old:# --- MakeMaker makefile section:
Makefile.old:	@echo "Makefile out-of-date with respect to $?"
Makefile.old:	-@$(RM_F) Makefile.old
Makefile.old:	-@$(MV) Makefile Makefile.old
Makefile.old:	-$(MAKE) -f Makefile.old clean $(DEV_NULL) || $(NOOP)
Makefile.old:# --- MakeMaker staticmake section:
Makefile.old:# --- MakeMaker makeaperl section ---
Makefile.old:	$(MAKE) -f $(MAKE_APERL_FILE) $@
Makefile.old:# --- MakeMaker test section:
Makefile.old:TESTDB_SW = -d
Makefile.old:	PERL_DL_NONLAZY=1 $(FULLPERLRUN) "-MExtUtils::Command::MM" "-e" "test_harness($(TEST_VERBOSE), '$(INST_LIB)', '$(INST_ARCHLIB)')" $(TEST_FILES)
Makefile.old:	PERL_DL_NONLAZY=1 $(FULLPERLRUN) "-I$(INST_LIB)" "-I$(INST_ARCHLIB)" $(TEST_FILE)
Makefile.old:	PERL_DL_NONLAZY=1 $(FULLPERLRUN) $(TESTDB_SW) "-I$(INST_LIB)" "-I$(INST_ARCHLIB)" $(TEST_FILE)
Makefile.old:# --- MakeMaker ppd section:
Makefile.old:	@$(PERL) -e "print qq{<SOFTPKG NAME=\"$(DISTNAME)\" VERSION=\"0,01,0,0\">\n\t<TITLE>$(DISTNAME)</TITLE>\n\t<ABSTRACT>Perl extensions for multitrack audio</ABSTRACT>\n\t<AUTHOR>Joel Roth &lt;jroth\@dsl-verizon.net&gt;</AUTHOR>\n}" > $(DISTNAME).ppd
Makefile.old:	@$(PERL) -e "print qq{\t<IMPLEMENTATION>\n}" >> $(DISTNAME).ppd
Makefile.old:	@$(PERL) -e "print qq{\t\t<OS NAME=\"$(OSNAME)\" />\n\t\t<ARCHITECTURE NAME=\"i686-linux-thread-multi\" />\n\t\t<CODEBASE HREF=\"\" />\n\t</IMPLEMENTATION>\n</SOFTPKG>\n}" >> $(DISTNAME).ppd
Makefile.old:# --- MakeMaker pm_to_blib section:
Makefile.old:	@$(PERLRUNINST) "-MExtUtils::Install" \
Makefile.old:	-e "pm_to_blib({qw{ecmd.pl blib/lib/Audio/Ecasound/ecmd.pl UI.pm blib/lib/Audio/Ecasound/UI.pm Grammar.pm blib/lib/Audio/Ecasound/Grammar.pm Config.pm blib/lib/Audio/Ecasound/Config.pm Iam.pm blib/lib/Audio/Ecasound/Iam.pm}},'$(INST_LIB)/auto','$(PM_FILTER)')"
Makefile.old:	@$(PERLRUNINST) "-MExtUtils::Install" \
Makefile.old:	-e "pm_to_blib({qw{Flow.pm blib/lib/Audio/Ecasound/Flow.pm}},'$(INST_LIB)/auto','$(PM_FILTER)')"
Makefile.old:# --- MakeMaker selfdocument section:
Makefile.old:# --- MakeMaker postamble section:
README:by adding high-level functionality to the Ecasound
README:based on the Tk widget set, and a command-line interface for
REFACTORING:3. Convert top-level lexicals to globals
REFACTORING:6. Saerch-and-replace them all as fully-qualified
UI.pm:UI - Perl extension for blah blah blah
UI.pm:Joel Roth, E<lt>jroth@dsl-verizon.netE<gt>
convert:#!/usr/local/bin/perl -w
convert:my $text = io($source)->all;
ecmd.pl:use lib '/home/jroth/ecmd-dev';
edit:cd ~/ecmd-dev/Audio/Ecasound
tags:!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
tags:Environment	Flow.pm	/^Environment: Normal or Hard Real-Time$/;"	l
tags:Environment	Flow2.pm	/^Environment: Normal or Hard Real-Time$/;"	l
tags:disconnect_transport	Flow.pm	/^sub disconnect_transport { &eval_iam('cs-disconnect') }$/;"	s
tags:disconnect_transport	Flow2.pm	/^sub disconnect_transport { &eval_iam('cs-disconnect') }$/;"	s
tags:ecasound_globals	Config.pm	/^ecasound_globals: -B auto$/;"	l
tags:format	Config.pm	/^    format:        cd-mono$/;"	l
tags:format	Config.pm	/^    format:        cd-stereo $/;"	l
tags:format	Config.pm	/^    format:        cd-stereo$/;"	l
tags:input_format	Config.pm	/^        input_format:  32-12 $/;"	l
tags:input_format	Config.pm	/^        input_format:  32-12$/;"	l
tags:input_format	Config.pm	/^        input_format:  cd-stereo$/;"	l
tags:m	Grammar.pm	/^m: 'm' dd  { $::state_c{$::chain{$::select_track}}->{ch_m} = $item{dd} }$/;"	l
tags:mono_to_stereo	Flow.pm	/^sub mono_to_stereo { " -erc:1,2 " }$/;"	s
tags:mono_to_stereo	Flow2.pm	/^sub mono_to_stereo { " -erc:1,2 " }$/;"	s
tags:output_format	Config.pm	/^        output_format: 32-10$/;"	l
tags:output_format	Config.pm	/^        output_format: cd-stereo$/;"	l
tags:r	Grammar.pm	/^r: 'r' dd  { $::state_c{$::chain{$::select_track}}->{ch_r} = $item{dd} }$/;"	l
test-class:	my $self = $$class->new;
test-class:my $tui = UI::Text->new;
test-class:$tui->hello;
test-class:my $gui = UI::Graphical->new;
test-class:$gui->hello;
test-class:my $ui = UI->new;
test-class:$ui->hello;
test-class:my $hui = UI->create("Text");
test-class:$hui->hello;
test-oo:my $ui = UI::Graphical->new;
test-oo:$ui->hello;
test-sub:#!/usr/local/bin/perl -w
test-sub:use lib q(/home/jroth/ecmd-dev);
test.pl:my $ui = UI->new;
test.pl:$ui->hello;
test.pl:my $tui = UI::Text->new;
test.pl:$tui->hello;
test.pl:my $gui = UI::Graphical->new;
test.pl:$gui->hello;
