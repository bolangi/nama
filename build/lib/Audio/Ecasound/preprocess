#!/usr/bin/env perl
use Template;
use IO::All;
use File::Find;
#use IO::Capture::STDOUT;

use vars qw( $dir, $exta, $extb, $special, %output_file,
%dispatcher );

my $debug = 1;
my $build = shift;
my $build_dir = $build ? $build : '/home/jroth/flow/build';
($exta, $extb) = qw( .p .pm);
$special = { Grammar => \&grammar, };
%output_file;
%dispatcher;

&preprocess( $build_dir, $exta, $extb, $special);

sub preprocess {
	($dir, $exta, $extb, $special) = @_;
	$debug and print "dir: $dir, exta: $exta, extb: $extb, special: ". ref $special, $/;
  find(\&filter, $dir);

}
sub filter { 
	my $ext = $exta;
	$ext =~ s/^\.//;
	my $re = qr/\.$ext$/;
	return if $File::Find::name =~ m(blib/lib);
	if ($File::Find::name =~ m(([^/]+)$re$) ){
		my $stub = $1;
		print "found stub: $stub\n";
		$debug and print "$_\n";
		$output_file{$stub} = "$File::Find::dir/$stub.$extb";
		&dispatch( $File::Find::dir ); 

	}
}

sub dispatch {
	my ($stub) = @_;
	! $stub and print("null key!\n skipped... "), last;
	$dispatcher{$stub} 
		and print ("starting preprocessor for $stub..\n") 
		and &{ $dispatcher{$stub} }($_, "$_$exta") and
		print "successful!\n"
			or print ("starting default preprocessor for $stub..\n"), 
				&default("$_$exta", "$_$extb");
}

sub default {
	$debug and print "default replace\n";
	my $template = Template->new;
	my ($input, $output) = @_; # Flow.p Flow.pm
	$debug and print "input: $input, output: $output\n";
	# custom routine
	# for some reason TT insists on routing to STDOUT

 #   my $capture = IO::Capture::Stdout->new();
#    $capture->start(); # STDOUT Output captured

	# process input template, substituting variables
	$template->process($input)
		 || die $template->error();
#    $capture->stop(); # STDOUT output sent to wherever it was before 'start'
#    @all_lines = $capture->read;
	print @all_lines;
	1;
}


sub grammar {

	$debug and print "grammar replace\n";

	my $template = Template->new;
	my $command_headers;

	# define template variables for replacement

	# specify input filename, or file handle, text reference, etc.
	my $input = 'Grammar.p';

	my $list = io('commands')->all;
	my $body = io('grammar_body')->all;
	$body =~ s/::/Audio::Ecasound::Flow::/g;


	my (@abbrevs, @stubs, @commands);

	map{

		my @parts = my @all_parts = split " ", $_;
		my $full = shift @parts;
		my @short = @parts;
		push @abbrevs,	"_$full: " . join (" | " , @all_parts);
		push @stubs,   	"$full: _$full {}";
		push @commands,	"command: $full";

	} split "\n", $list;

	my $command_headers = join "\n", @commands, @abbrevs, @stubs ;

	my $vars = { 
		commands 	 => $command_headers,
		grammar_body => $body,
	};
# process input template, substituting variables
$template->process($input, $vars)
	 || die $template->error();
1;
}
	
__END__

