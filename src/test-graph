#!/usr/local/bin/perl 
use Modern::Perl;
use Graph;
my $g = Graph->new;
$g->add_path(qw[ wav_in piano Master Eq Low Boost soundcard_out]) ;
$g->add_path(qw[ Eq High Boost]);

say "The initial graph is $g";

my %reserved = map{ $_, 1} qw( soundcard_in soundcard_out wav_in wav_out jack_in jack_out );

my $gr = insert_loops($g);

# insert loop devices

say "The loop-expanded graph is $gr";

sub insert_loops {
	my $g = shift;
	my $gr = Graph->new();
	map{ my($a,$b) = @$_; 
		 $gr->add_path( first_segment($a),second_segment($b) )
	# 	 say join " ", "in: ", first_segment($a);
	# 	 say join " ", "out:", second_segment($b); 
		#say( join " ", first_segment($a), second_segment($b) );
		} $g->edges;
	$gr
}

sub in_loop{ "$_[0]_in" }
sub out_loop{ "$_[0]_out" }
	
sub first_segment {
	my $v = shift;
	is_terminal($v) ? $v : ($v, out_loop($v))
}
sub second_segment{
	my ($v) = @_;
	is_terminal($v) ? $v : (in_loop($v),  $v)
}	

sub is_terminal { $reserved{$_[0]} }

sub eliminate_loops {
	my $g = shift;
=comment

- remove loop between soundcard and track

soundcard_in -> sax_in --> sax

my @s = $g->successors("sax_in");

- remove loop between track and soundcard

Master -> Master_out -> soundcard_out

- remove one loop between track and track

-- case 1

Eq -> Eq_out -> Low_in -> Low

my @s = $g->successors("Eq_out");

eliminate Eq_out if one successor and successor is not track

eliminate Low_in if one successor 
	and successor is track
	and predecessor is not track

-- case 2

Low -> Low_out -> Boost_in -> Boost

elimnate Low_out if one successor
    and successor is loop

=cut
	
}
	

#map{ say @$_ } $g->edges_from('soundcard_in');

__END__

	
=comment

piano-Master   			track track
soundcard_in-sax		device track
Master-soundcard_out	track device
soundcard_in-soundcard_out device device


remove piano-Master
replace with piano-piano_out-Master_in-Master

track-loop1-loop2-track
track-loop3-loop2-track

both paths share loop2-track
both paths have double loops, loop1-loop2, loop3-loop2

source/sink vertices of every graph will _not_ be tracks


my @s = $g->source_vertices;
route(undef, @s);
sub is_loop(
	my $name = shift;
	return if $reserved{$name};
	if (my($root, $suffix) = $name =~ /(.+)(_(in|out))/
		and $tn{$root}){
	
		return $root;
	} else { croak "illegal vertex name: $name" }
}
sub is_a_track{ $tn{$_[0]} }


=comment

cases for routing tracks

input is device, output is device
input is device, output is track
input is track, output is device
input is track, output is track

sub route {
	my ($source, @successors) = @_;
	# we assume $source is already routed
	for my $s( @successors) { 
		if ( $reserved{$s} ){ 
			# source/sink, do nothing with $s
	 	} elsif ( my $t = $tn{$s} ){  # is a track
			my $chain_id = $t->n;
			my $p_count = $g->predecessors($s); # number of predecessors
			my ($type, $object) = source_type_object($source, $t, $p_count);
			push @{ $inputs{$type}->{$object}, $chain_id;

			# we may have more than one output

			my @successors = $g->successors($s);
				for my $s2
			
			($type, $object) = 
			push @{ $output
			
					my $output = $loop_input{$s};
					route_io( 	dir => 'output', 
								type => 'loop', 
								object => $output, 
								chains => [ chains( @p )],
		
		} else { carp "illegal vertex name: $s" }
			

sub need_output_loop {
	my $name = shift;

	# need a loop to branch out or to feed another track
	
	$g->successors($name) > 1

		or grep{ $tn{$_} } $g->successors($name)  	
}	
	
sub source_type_object {
	my ($source, $track, $p_count) = @_;

		# use loop if multiple predecessors
		# or at least one track predecessor

		# use source's output loop if only one track  predecessor 
		if ($p_count == 1 and $tn{$source}) {
			return ('loop',"$source_out")
			
		if ($source eq 'soundcard') { 
			# post_input $track->rec_route TODO
			return ($soundcard_input->type, $soundcard_input->object)
		} elsif ($source eq 'jack_client') {
			return ('jack_client',$track->source_id);
			

) # source is track
			

sub route_inputs {
	my @p = @_;
	map{ 

		


 } @p;

{ my %loops = ();
  my $i = 0;
sub get_loop {
	my $n = shift;
	return 'L'.$loops{$n} if $loops{$n};
	$loops{$n} = ++$i;
	get_loop($n)
}
}

	
	



sub chains {
	my @names = @_;
	map{ $_->n } map{$tn{$_}} @names;
}
	
sub send_to_soundcard {
	my @names = @_;
 	push @{ $outputs{ $soundcard_output->type }{ $soundcard_output->object },
		map{ $_->n } map{$tn{$_}} @names;
	map{ push
}

sub loop_input {
	
	

__END__

sax Master

sax-->Master
sax-->Master
soundcard-->sax_in---->sax_out--->Master
soundcard-->sax_in---->sax_out--->Master-->Eq-->Low/Mid/High-->Boost
sax_in --> WAV

look at sax_in

cases:

1) signal from out tracks
2) signal from soundcard/JACK client

sax-->(insert)-->Master
sax-->(wet/dry insert)-->Master
sax-->sax_insert_1_wet-->Master
sax-->sax_insert_1_dry-->Master



rewrite mix_setup



