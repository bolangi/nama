#!/usr/bin/env perl

# fields that may contain a track name

# Fade: track
# Bus: name
# Track: name group source_id send_id target current_edit
# Insert: send_id return_id wet_track dry_track track
# Edit: host_track
# EffectChain: not supported
# IO: not necessary, generated dynamically


my $oldname = "vcoal";
my $newname = "vocal";
my $file = 
#my $test = q("retun_id" : "vcoal");

sub rename_track {
	use Cwd;
	use File::Slurp;
	my ($oldname, $newname, $statefile, $dir) = @_;
	my $old_dir = cwd();
	chdir $dir;

	# rename audio files
	
	qx(rename 's/^$oldname(?=[_.])/$newname$1/' *.wav);


	# rename in State.json when candidate key
	# is part of the specified set and the value 
	# exactly matches $oldname
	
	my $state = read_file($statefile);

	$state =~ s/
		"					# open quote
		(track| 		# one of specified fields
		name| 
		group| 
		source| 
		send_id| 
		target| 
		current_edit| 
		send_id| 
		return_id| 
		wet_track| 
		dry_track| 
		track| 
		host_track)
		"				# close quote
		\ 				# space
		:				# colon
		\ 				# space
		"$oldname"/"$1" : "$newname"/x;

write_file($statefile);
}
print $test, $/;
my @names = qw(vocal.wav vocal_1.wav);
map{ 
$_ =~ s/^$oldname(?=[_.])/$newname$1/;
say
} @names;
