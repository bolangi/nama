.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "UI::UI 3"
.TH UI::UI 3 "2007-12-21" "perl v5.8.0" "User Contributed Perl Documentation"
.Vb 4
\&        find_op_offsets reads the output of the cs command to determine
\&        the number of chain operators from the setup file, then adds 
\&        two for the volume and pan operators, to give the index offset
\&        for the first user effect.
.Ve
.PP
.Vb 1
\&        Here is the relevant line from the 'cs' command output:
.Ve
.PP
.Vb 1
\&                Chain "1" [selected] "Channel copy"
.Ve
.PP
.Vb 4
\&        we will count the quotes, divide by two, and subtract one (for the chain id)
\&        to get offset. Then we add two for volume and pan. Finally, we will
\&        add 1, since perl arrays (used to represent chain operators) are indexed
\&        starting at 0, whereas ecasound indexes operators starting at 1.
.Ve
.PP
.Vb 3
\&        In this example, the first user effect will have an index of 4, which
\&        will also be the offset needed for our start-at-zero array. 
\&=cut
.Ve
.PP
.Vb 15
\&        # my $debug = 1;
\&        $debug2 and print "&find_op_offsets\en";
\&        eval_iam('c-select-all');
\&                my @op_offsets = split "\en",eval_iam("cs");
\&                shift @op_offsets; # remove comment line
\&                $debug and print join "\en\en",@op_offsets; 
\&                for my $output (@op_offsets){
\&                        my $chain_id;
\&                        ($chain_id) = $output =~ m/Chain "(\ew*\ed+)"/;
\&                        print "chain_id: $chain_id\en";
\&                        next if $chain_id =~ m/\eD/; # skip id's containing non-digits
\&                                                                                # i.e. M1
\&                        my $quotes = $output =~ tr/"//;
\&                        $debug and print "offset: $quotes in $output\en"; 
\&                        $state_c{$chain_id}->{offset} = ($quotes/2 - 1) + 1;
.Ve
.PP
.Vb 25
\&                }
\&}
\&sub apply_ops {  # in addition to operators in .ecs file
\&        $debug2 and print "&apply_ops\en";
\&        # my $debug = 1;
\&        for my $n (@all_chains) {
\&        $debug and print "chain: $n, offset: $state_c{$n}->{offset}\en";
\&                next if rec_status($n) eq $UI::MUTE and $n != 1; #MIX
\&                next if ! defined $state_c{$n}->{offset}; # for MIX
\&                next if ! $state_c{$n}->{offset} ;
\&                for my $id ( @{ $state_c{$n}->{ops} } ) {
\&                #       next if $cops{$id}->{belongs_to}; 
\&                apply_op($id);
\&                }
\&        }
\&}
\&sub apply_op {
\&        # my $debug = 1;
\&        $debug2 and print "&apply_op\en";
\&        my $id = shift;
\&        $debug and print "id: $id\en";
\&        my $code = $cops{$id}->{type};
\&        $debug and print "chain: $cops{$id}->{chain} type: $cops{$id}->{type}, code: $code\en";
\&        #  if code contains colon, then follow with comma (preset, LADSPA)
\&        #  if code contains no colon, then follow with colon (ecasound,  ctrl)
.Ve
.PP
.Vb 3
\&        $code = '-' . $code . ($code =~ /:/ ? q(,) : q(:) );
\&        my @vals = @{ $copp{$id} };
\&        $debug and print "values: @vals\en";
.Ve
.PP
.Vb 1
\&        # we start to build iam command
.Ve
.PP
.Vb 2
\&        my $add = "cop-add "; 
\&        $add .= $code . join ",", @vals;
.Ve
.PP
.Vb 1
\&        # if my parent has a parent then we need to append the -kx  operator
.Ve
.PP
.Vb 3
\&        my $dad = $cops{$id}->{belongs_to};
\&        $add .= " -kx" if $cops{$dad}->{belongs_to};
\&        $debug and print "operator:  ", $add, "\en";
.Ve
.PP
.Vb 5
\&        eval_iam ("c-select $cops{$id}->{chain}") 
\&                unless $cops{$id}->{belongs_to}; # avoid reset
\&        eval_iam ($add);
\&        $debug and print "children found: ", join ",", "|",@{$cops{$id}->{owns}},"|\en";
\&        map{apply_op($_)} @{ $cops{$id}->{owns} };
.Ve
.PP
}
## static effects data
.PP
# \f(CW@ladspa_sorted\fR # \s-1XXX\s0
.PP
sub prepare_static_effects_data{
.PP
.Vb 1
\&        my $effects_cache = join_path($wav_dir, $effects_cache_file);
.Ve
.PP
.Vb 2
\&        # TODO re-read effects data if ladspa or user presets are
\&        # newer than cache
.Ve
.PP
.Vb 11
\&        if (-f $effects_cache){ 
\&                $debug and print "looking for effects cache: $effects_cache\en";
\&                assign_vars($effects_cache, @effects_static_vars);
\&        } else {
\&                $debug and print "reading in effects data\en";
\&                read_in_effects_data(); 
\&                get_ladspa_hints();
\&                integrate_ladspa_hints();
\&                sort_ladspa_effects();
\&                store_vars($effects_cache, @effects_static_vars);
\&        }
.Ve
.PP
}
sub extract_effects_data {
	my ($lower, \f(CW$upper\fR, \f(CW$regex\fR, \f(CW$separator\fR, \f(CW@lines\fR) = \f(CW@_\fR;
	carp (\*(L"incorrect number of lines \*(R", join ' ',$upper\-$lower,scalar \f(CW@lines\fR)
		if \f(CW$lower\fR + \f(CW@lines\fR \- 1 != \f(CW$upper\fR;
	\f(CW$debug\fR and print\*(L"lower: \f(CW$lower\fR upper: \f(CW$upper\fR  separator: \f(CW$separator\fR\en\*(R";
	#$debug and print \*(L"lines: \*(R". join \*(L"\en\*(R",@lines, \*(L"\en\*(R";
	\f(CW$debug\fR and print \*(L"regex: \f(CW$regex\fR\en\*(R";
.PP
.Vb 2
\&        for (my $j = $lower; $j <= $upper; $j++) {
\&                my $line = shift @lines;
.Ve
.PP
.Vb 28
\&                $line =~ /$regex/ or carp("bad effect data line: $line\en"),next;
\&                my ($no, $name, $id, $rest) = ($1, $2, $3, $4);
\&                $debug and print "Number: $no Name: $name Code: $id Rest: $rest\en";
\&                my @p_names = split $separator,$rest; 
\&                map{s/'//g}@p_names; # remove leading and trailing q(') in ladspa strings
\&                $debug and print "Parameter names: @p_names\en";
\&                $effects[$j]={};
\&                $effects[$j]->{number} = $no;
\&                $effects[$j]->{code} = $id;
\&                $effects[$j]->{name} = $name;
\&                $effects[$j]->{count} = scalar @p_names;
\&                $effects[$j]->{params} = [];
\&                $effects[$j]->{display} = qq(field);
\&                map{ push @{$effects[$j]->{params}}, {name => $_} } @p_names;
\&        }
\&}
\&sub sort_ladspa_effects {
\&        $debug2 and print "&sort_ladspa_effects\en";
\&#       print yaml_out(\e%e_bound); 
\&        my $aa = $e_bound{ladspa}{a};
\&        my $zz = $e_bound{ladspa}{z};
\&#       print "start: $aa end $zz\en";
\&        map{push @ladspa_sorted, 0} ( 1 .. $aa ); # fills array slice [0..$aa-1]
\&        splice @ladspa_sorted, $aa, 0,
\&                 sort { $effects[$a]->{name} cmp $effects[$b]->{name} } ($aa .. $zz) ;
\&#               print "length: ". scalar @ladspa_sorted, "\en";
\&}               
\&sub read_in_effects_data {
.Ve
.PP
.Vb 1
\&        read_in_tkeca_effects_data();
.Ve
.PP
.Vb 1
\&        # read in other effects data
.Ve
.PP
.Vb 1
\&        my @ladspa = grep {! /^\ew*$/ } split "\en", eval_iam("ladspa-register");
.Ve
.PP
.Vb 2
\&        # join the two lines of each entry
\&        my @lad = map { join " ", splice(@ladspa,0,2) } 1..@ladspa/2;
.Ve
.PP
.Vb 2
\&        my @preset = grep {! /^\ew*$/ } split "\en", eval_iam("preset-register");
\&        my @ctrl  = grep {! /^\ew*$/ } split "\en", eval_iam("ctrl-register");
.Ve
.PP
.Vb 1
\&        # index boundaries we need to make effects list and menus
.Ve
.PP
.Vb 10
\&        $e_bound{ladspa}{a} = $e_bound{tkeca}{z} + 1;
\&        $e_bound{ladspa}{b} = $e_bound{tkeca}{z} + int(@lad/4);
\&        $e_bound{ladspa}{c} = $e_bound{tkeca}{z} + 2*int(@lad/4);
\&        $e_bound{ladspa}{d} = $e_bound{tkeca}{z} + 3*int(@lad/4);
\&        $e_bound{ladspa}{z} = $e_bound{tkeca}{z} + @lad;
\&        $e_bound{preset}{a} = $e_bound{ladspa}{z} + 1;
\&        $e_bound{preset}{b} = $e_bound{ladspa}{z} + int(@preset/2);
\&        $e_bound{preset}{z} = $e_bound{ladspa}{z} + @preset;
\&        $e_bound{ctrl}{a}   = $e_bound{preset}{z} + 1;
\&        $e_bound{ctrl}{z}   = $e_bound{preset}{z} + @ctrl;
.Ve
.PP
.Vb 10
\&        my $preset_re = qr/
\&                ^(\ed+) # number
\&                \e.    # dot
\&                \es+   # spaces+
\&                (\ew+) # name
\&                ,\es*  # comma spaces* 
\&                -(pn:\ew+)    # preset_id 
\&                :?     # maybe colon (if parameters)
\&                (.*$)  # rest
\&        /x;
.Ve
.PP
.Vb 9
\&        my $ladspa_re = qr/
\&                ^(\ed+) # number
\&                \e.    # dot
\&                \es+  # spaces
\&                (\ew.+?) # name, starting with word-char,  non-greedy
\&                \es+     # spaces
\&                -(el:\ew+),? # ladspa_id maybe followed by comma
\&                (.*$)        # rest
\&        /x;
.Ve
.PP
.Vb 9
\&        my $ctrl_re = qr/
\&                ^(\ed+) # number
\&                \e.     # dot
\&                \es+    # spaces
\&                (\ew.+?) # name, starting with word-char,  non-greedy
\&                ,\es*    # comma, zero or more spaces
\&                -(k\ew+):?    # ktrl_id maybe followed by colon
\&                (.*$)        # rest
\&        /x;
.Ve
.PP
.Vb 7
\&        extract_effects_data(
\&                $e_bound{ladspa}{a},
\&                $e_bound{ladspa}{z},
\&                $ladspa_re,
\&                q(','),
\&                @lad,
\&        );
.Ve
.PP
.Vb 14
\&        extract_effects_data(
\&                $e_bound{preset}{a},
\&                $e_bound{preset}{z},
\&                $preset_re,
\&                q(,),
\&                @preset,
\&        );
\&        extract_effects_data(
\&                $e_bound{ctrl}{a},
\&                $e_bound{ctrl}{z},
\&                $ctrl_re,
\&                q(,),
\&                @ctrl,
\&        );
.Ve
.PP
.Vb 6
\&        for my $i (0..$#effects){
\&                no warnings;
\&                 $effect_i{ $effects[$i]->{code} } = $i; 
\&                 use warnings;
\&                 $debug and print "i: $i code: $effects[$i]->{code} display: $effects[$i]->{display}\en";
\&        }
.Ve
.PP
.Vb 3
\&        $debug and print "\e@effects\en======\en", yaml_out(\e@effects); ; 
\&}
\&sub read_in_tkeca_effects_data {
.Ve
.PP
# Based on \s-1GPL\s0 code in Tkeca
.PP
# controller (effect) data format
# code|name|number_of_parameters| ( Label|scale_start|scale_end|default|resolution ) x number_of_parameters
.PP
# I left the tcl code 'as is' in the following pasted section, using regexes 
# so future updates from him can be pasted in without editing.
.PP
# divide by lines, remove stuff outside quotes, 
# then make an anonymous array of the fields of each line
.PP
.Vb 3
\&        my @effects_data =      map { [split /\e|/, $_ ]  }  
\&                                                map{ s/^.*?"//; s/"\es*$//; $_} 
\&                                                split "\en",$tkeca_effects_data;
.Ve
.PP
.Vb 2
\&        $e_bound{tkeca}{a}  = 1;
\&        $e_bound{tkeca}{z}  = scalar @effects_data;
.Ve
.PP
.Vb 3
\&        for my $i (1..@effects_data){
\&                my @row = @{ shift @effects_data };
\&                @{$effects[$i]}{ qw(code name count) } = splice @row, 0, 3;
.Ve
.PP
.Vb 1
\&                # default display format
.Ve
.PP
.Vb 1
\&                $effects[$i]->{display} = qq(scale);
.Ve
.PP
.Vb 3
\&        # maps effect code (i.e. epp) to an index in array holding static effects data
\&        #print "effects code: $i stands for ", $effects[$i]->{code}, "\en";
\&        #print "count: $effects[$i]->{count}\en";
.Ve
.PP
.Vb 6
\&                        for (1..$effects[$i]->{count}){
\&                                my %p;
\&                                #print join " / ",splice (@row, 0,5), "\en";
\&                                @p{ qw(name begin end default resolution) }  =  splice @row, 0, 5;
\&                                # print "\e%p\en======\en", yaml_out (\e%p);
\&                                push @{$effects[$i]->{params}}, \e%p;
.Ve
.PP
.Vb 2
\&                        }
\&        }
.Ve
.PP
}
sub get_ladspa_hints{
	\f(CW$debug2\fR and print \*(L"&get_ladspa_hints\en\*(R";
	my \f(CW@dirs\fR =  split ':', \f(CW$ENV\fR{\s-1LADSPA_PATH\s0};
	my \f(CW$data\fR = '';
	for my \f(CW$dir\fR (@dirs) {
		opendir \s-1DIR\s0, \f(CW$dir\fR or carp qq(can't open \s-1LADSPA\s0 dir \*(L"$dir\*(R" for read: $!\en);
		my \f(CW@plugins\fR = grep{ /\e.so$/ } readdir \s-1DIR\s0;
		\f(CW$data\fR .= join "\*(L", map { `analyseplugin \f(CW$_\fR` } \f(CW@plugins\fR;
		closedir \s-1DIR\s0;
	}
	# print \f(CW$data\fR; exit;
	my \f(CW@plugin_stanzas\fR = split \*(R"\en\en\en", \f(CW$data\fR;
	# print scalar \f(CW@plugin_stanzas\fR; exit;
	# print \f(CW$data\fR;
.PP
.Vb 4
\&        # print "@plugins"; exit;
\&        # | perl -ne 'chomp; s/$ENV{LADSPA_PATH}//; system qq(analyseplugin $_)'
\&        my $ladspa_sample_rate = 44100; # for sample-rate dependent effect
\&        use Data::Dumper;
.Ve
.PP
.Vb 6
\&        my $pluginre = qr/
\&        Plugin\e Name: \es+ "([^"]+)" \es+
\&        Plugin\e Label:\es+ "([^"]+)" \es+
\&        [^\ex00]+(?=Ports)               # swallow maximum up to Ports
\&        Ports: \es+ ([^\ex00]+)   # swallow all
\&        /x;
.Ve
.PP
.Vb 5
\&        my $paramre = qr/
\&        "([^"]+)"   #  name inside quotes
\&        \es+
\&        (.+)        # rest
\&        /x;
.Ve
.PP
.Vb 1
\&        for my $stanza (@plugin_stanzas) {
.Ve
.PP
.Vb 1
\&                $stanza =~ /$pluginre/ or carp "*** couldn't match plugin stanza $stanza ***";
.Ve
.PP
.Vb 2
\&                my ($plugin_name, $plugin_label, $ports) = ($1, $2, $3);
\&                #print "$1\en$2\en$3"; exit;
.Ve
.PP
.Vb 3
\&                 my @lines = split "\en",$ports;
\&        #       print join "\en",@lines; exit;
\&                my @params;  # data
.Ve
.PP
.Vb 19
\&                my @names;
\&                for my $p (@lines) {
\&                        next if $p =~ /^\es*$/;
\&                        $p =~ /$paramre/;
\&                        my ($name, $rest) = ($1, $2);
\&                        my ($dir, $type, $range, $default, $hint) = split /\es*,\es*/ , $rest, 5;
\&                        #print join "|",$dir, $type, $range, $default, $hint;
\&                        next if $type eq q(audio);
\&                        my %p;
\&                        $p{name} = $name;
\&                        $p{dir} = $dir;
\&                        $p{hint} = $hint;
\&                        my ($beg, $end, $default_val, $resolution) = range($name, $range, $default, $hint);
\&                        $p{begin} = $beg;
\&                        $p{end} = $end;
\&                        $p{default} = $default_val;
\&                        $p{resolution} = $resolution;
\&                        push @params, { %p };
\&                }
.Ve
.PP
.Vb 5
\&                $plugin_label = "el:" . $plugin_label;
\&                $effects_ladspa {$plugin_label}->{params} = [ @params ];
\&                $effects_ladspa {$plugin_label}->{count} = scalar @params;
\&                $effects_ladspa {$plugin_label}->{display} = 'scale';
\&        }
.Ve
.PP
.Vb 20
\&        #print "@params\en";
\&        #print yaml_out \e%params;
\&        $debug and print yaml_out (\e%effects_ladspa); 
\&}
\&no warnings;
\&sub range {
\&        my ($name, $range, $default, $hint) = @_; 
\&        my $multiplier = 1;;
\&        $multiplier = $ladspa_sample_rate if $range =~ s/\e*srate//g;
\&        my ($beg, $end) = split /\es+to\es+/, $range;
\&        # if end is '...' set to $default + 10dB or $default * 10
\&        $default =~ s/default\es+//;
\&        $end =~ /\e.{3}/ and $end = (
\&                $default == 0 ? 10  # '0' is probably 0db, so 0+10db
\&                                          : $default * 10
\&                );
\&#       print "1 beg: $beg  end: $end\en";
\&        $beg = $beg * $multiplier;
\&        $end = $end * $multiplier;
\&#       print "2 beg: $beg  end: $end\en";
.Ve
.PP
.Vb 9
\&        my $resolution = ($end - $beg) / 100;
\&        if    ($hint =~ /integer/ ) { $resolution = 1; }
\&        elsif ($hint =~ /logarithmic/ ) {
\&                $beg = 0.0001 * $multiplier if ! $beg;
\&                $beg = round ( log $beg );
\&                $end = round ( log $end );
\&                $resolution = ($end - $beg) / 100;
\&                $default = round (log $default);
\&        }
.Ve
.PP
.Vb 3
\&        $resolution = d2( $resolution + 0.002) if $resolution < 1  and $resolution > 0.01;
\&        $resolution = dn ( $resolution, 3 ) if $resolution < 0.01;
\&        $resolution = int ($resolution + 0.1) if $resolution > 1 ;
.Ve
.PP
.Vb 2
\&        #print "3 beg: $beg  end: $end\en";
\&        ($beg, $end, $default, $resolution)
.Ve
.PP
}
use warnings;
sub integrate_ladspa_hints {
	map{ 
		my \f(CW$i\fR = \f(CW$effect_i\fR{$_};
		print (\*(L"$_ not found\en\*(R"), next unless \f(CW$i\fR;
		\f(CW$effects\fR[$i]\->{params} = \f(CW$effects_ladspa\fR{$_}\->{params};
		\f(CW$effects\fR[$i]\->{display} = \f(CW$effects_ladspa\fR{$_}\->{display};
	} keys \f(CW%effects_ladspa\fR;
=comment
.PP
my \f(CW%L\fR;
my \f(CW%M\fR;
.PP
map { \f(CW$L\fR{$_}++ } keys \f(CW%effects_ladspa\fR;
map { \f(CW$M\fR{$_}++ } grep {/el:/} keys \f(CW%effect_i\fR;
.PP
for my \f(CW$k\fR (keys \f(CW%L\fR) {
	\f(CW$M\fR{$k} or print \*(L"$k not found in ecasound listing\en\*(R";
}
for my \f(CW$k\fR (keys \f(CW%M\fR) {
	\f(CW$L\fR{$k} or print \*(L"$k not found in ladspa listing\en\*(R";
}
exit;
.PP
print join \*(L"\en\*(R", sort keys \f(CW%effects_ladspa\fR;
print '\-' x 60, \*(L"\en\*(R";
print join \*(L"\en\*(R", grep {/el:/} sort keys \f(CW%effect_i\fR;
.PP
#print yaml_out \e@effects; exit;
exit;
.PP
.Vb 1
\& ls $LADSPA_PATH | perl -ne 'chomp; s/$ENV{LADSPA_PATH}//; system qq(analyseplugin $_)'
.Ve
.PP
my \f(CW$ds\fR = q(
Plugin Name: \*(L"\s-1LS\s0 Filter\*(R"
Plugin Label: \*(L"lsFilter\*(R"
Plugin Unique \s-1ID:\s0 1908
Maker: \*(L"Steve Harris <steve@plugin.org.uk>\*(R"
Copyright: \*(L"\s-1GPL\s0\*(R"
Must Run Real\-Time: No
Has \fIactivate()\fR Function: Yes
Has \fIdeativate()\fR Function: No
Has \fIrun_adding()\fR Function: Yes
Environment: Normal or Hard Real-Time
Ports:  \*(L"Filter type (0=LP, 1=BP, 2=HP)\*(R" input, control, 0 to 2, default 0, integer
        \*(L"Cutoff frequency (Hz)\*(R" input, control, 0.002*srate to 0.5*srate, default 0.0316228*srate, logarithmic
        \*(L"Resonance\*(R" input, control, 0 to 1, default 0
        \*(L"Input\*(R" input, audio
        \*(L"Output\*(R" output, audio
);
=cut
## persistent state support
.PP
sub save_state {
	\f(CW$debug2\fR and print \*(L"&save_state\en\*(R";
	my \f(CW$file\fR = shift;
	# restore muted volume levels
	#
	my \f(CW%muted\fR;
.PP
.Vb 6
\&        map{ $copp{ $state_c{$_}{vol} }->[0] = $old_vol{$_} ;
\&                 $muted{$_}++;
\&        #        paint_button($widget_c{$_}{mute}, q(brown) );
\&                }
\&        grep { $old_vol{$_} }  # old vol level has been stored, thus is muted
\&        @all_chains;
.Ve
.PP
.Vb 1
\&        store_vars($file, @persistent_vars);
.Ve
.PP
# store alsa settings
.PP
.Vb 2
\&        my $result2 = system "alsactl -f $file.alsa store";
\&        $debug and print "alsactl store result: ", $result2 >>8, "\en";
.Ve
.PP
.Vb 1
\&        # now remute
.Ve
.PP
.Vb 3
\&        map{ $copp{ $state_c{$_}{vol} }->[0] = 0} 
\&        grep { $muted{$_}} 
\&        @all_chains;
.Ve
.PP
}
=comment
=cut
sub retrieve_state {
	# look for yaml if not look for standard
.PP
.Vb 15
\&        $debug2 and print "&retrieve_state\en";
\&        my ($file)  = shift; # assuming $file will never have .yaml
\&        my $yamlfile = "$file.yaml" ;
\&        my $ref; # to receive yaml data
\&        if (-f $yamlfile) {
\&                $debug and print qq($yamlfile: YAML file found\en), return;
\&                $ref = assign_vars($yamlfile, @persistent_vars);
\&        } elsif (-f $file) {
\&                $debug and print qq($file: 'Storable' file found\en), return;
\&                $ref = assign_vars($file, @persistent_vars);
\&        } else {
\&                $debug and 
\&                carp("no state files found, neither $file, nor $yamlfile\en");
\&                return;
\&        }
.Ve
.PP
.Vb 1
\&        # variables successfully assigned
.Ve
.PP
.Vb 4
\&        my $toggle_jack = $widget_o[$#widget_o];
\&        convert_to_jack if $jack_on;
\&        paint_button($toggle_jack, q(lightblue)) if $jack_on;
\&        refresh_oids();
.Ve
.PP
.Vb 1
\&        # restore mixer settings
.Ve
.PP
.Vb 2
\&        my $result = system "sudo alsactl -f $file.alsa restore";
\&        $debug and print "alsactl restore result: " , $result >> 8 , "\en";
.Ve
.PP
.Vb 1
\&        # restore time marker labels
.Ve
.PP
.Vb 5
\&        map{ $time_marks[$_]->configure( 
\&                -text => colonize($marks[$_]),
\&                -background => $old_bg,
\&        )} 
\&        grep{ $marks[$_] }1..$#time_marks;
.Ve
.PP
.Vb 1
\&        # restore take and track guis
.Ve
.PP
.Vb 13
\&        for my $t (@takes) { 
\&                next if $t == 1; 
\&                take_gui($t);
\&        }; #
\&        my $did_apply = 0;
\&        $last_version = 0; 
\&        for my $n (@all_chains) { 
\&                $debug and print "restoring track: $n\en";
\&                restore_track($n) ;
\&                for my $id (@{$state_c{$n}->{ops}}){
\&                        $did_apply++ 
\&                                unless $id eq $state_c{$n}->{vol}
\&                                        or $id eq $state_c{$n}->{pan};
.Ve
.PP
.Vb 6
\&                        add_effect({
\&                                                chain => $cops{$id}->{chain},
\&                                                type => $cops{$id}->{type},
\&                                                cop_id => $id,
\&                                                parent_id => $cops{$id}->{belongs_to},
\&                                                });
.Ve
.PP
.Vb 5
\&                # TODO if parent has a parent, i am a parameter controller controlling
\&                # a parameter controller, and therefore need the -kx switch
\&                }
\&        }
\&        $did_apply and manifest(); # $ew->deiconify();
.Ve
.PP
}
.PP
sub save_effects {
	\f(CW$debug2\fR and print \*(L"&save_effects\en\*(R";
	my \f(CW$file\fR = shift;
.PP
.Vb 3
\&        # restore muted volume levels
\&        #
\&        my %muted;
.Ve
.PP
.Vb 4
\&        map  {$copp{ $state_c{$_}{vol} }->[0] = $old_vol{$_} ;
\&                  paint_button($widget_c{$_}{mute}, $old_bg ) }
\&        grep { $old_vol{$_} }  # old vol level stored and muted
\&        @all_chains;
.Ve
.PP
.Vb 5
\&        # we need the ops list for each track
\&        #
\&        # i dont see why, do we overwrite the effects section
\&        # in one of the init routines?
\&        # I will follow for now 12/6/07
.Ve
.PP
.Vb 2
\&        %state_c_ops = ();
\&        map{    $state_c_ops{$_} = $state_c{$_}->{ops} } @all_chains;
.Ve
.PP
.Vb 1
\&        # map {remove_op} @{ $state_c{$_}->{ops} }
.Ve
.PP
.Vb 2
\&        store_vars($file, @effects_dynamic_vars);
\&}
.Ve
.PP
sub r5 { r(\*(L"eff5\*(R") };
=cut
sub retrieve_effects {
	#my \f(CW$debug\fR = 1;
	\f(CW$debug2\fR and print \*(L"&retrieve_effects\en\*(R";
	my \f(CW$file\fR = shift;
	my \f(CW%current_cops\fR = \f(CW%cops\fR; # \s-1XXX\s0 why bother
	my \f(CW%current_copp\fR = \f(CW%copp\fR; # similar name!!!!
	assign_vars($file, \f(CW@effects_dynamic_vars\fR);
	my \f(CW%old_copp\fR = \f(CW%copp\fR;  # \s-1XXX\s0 why bother
	my \f(CW%old_cops\fR = \f(CW%cops\fR; 
	\f(CW%cops\fR = \f(CW%current_cops\fR;
	\f(CW%copp\fR = \f(CW%current_copp\fR; ## similar name!!
.PP
.Vb 4
\&        print "\e%state_c_ops\en ", yaml_out( \e%state_c_ops), "\en\en";
\&        print "\e%old_cops\en ", yaml_out( \e%old_cops), "\en\en";
\&        print "\e%old_copp\en ", yaml_out( \e%old_copp), "\en\en";
\&#       return;
.Ve
.PP
.Vb 1
\&        # restore time marker labels
.Ve
.PP
.Vb 9
\&        map{ $time_marks[$_]->configure( 
\&                -text => $marks[$_]
\&                        ?  colonize($marks[$_])
\&                        :  $_,
\&                -background => $marks[$_]
\&                        ?  $old_bg
\&                        : q(lightblue),
\&                )
\&        } 1..$#time_marks;
.Ve
.PP
.Vb 1
\&        # remove effects except vol and pan, in which case, update vals
.Ve
.PP
.Vb 1
\&        map{
.Ve
.PP
.Vb 2
\&                $debug and print "found chain $_: ", join " ",
\&                @{ $state_c{$_}->{ops} }, "\en";
.Ve
.PP
.Vb 3
\&                my $n = $_;
\&                map {   my $id = $_; 
\&                                $debug and print "checking chain $n, id $id: ";
.Ve
.PP
.Vb 2
\&                                if (    $state_c{$n}->{vol} eq $id or
\&                                                $state_c{$n}->{pan} eq $id  ){
.Ve
.PP
.Vb 2
\&                                        # do nothing
\&                                $debug and print "is vol/pan\en";
.Ve
.PP
.Vb 2
\&                                }
\&                                else {
.Ve
.PP
.Vb 4
\&                                        $debug and print "is something else\en";
\&                                        remove_effect($id) ;
\&                                        remove_op($id)
\&                        }
.Ve
.PP
.Vb 2
\&                } @{ $state_c{$_}->{ops} }
\&        } @all_chains;
.Ve
.PP
.Vb 1
\&        return;
.Ve
.PP
.Vb 1
\&        # restore ops list
.Ve
.PP
.Vb 1
\&        map{ $state_c{$_}->{ops} = $state_c_ops{$_} } @all_chains;
.Ve
.PP
.Vb 1
\&        # restore ops->chain mapping
.Ve
.PP
.Vb 1
\&        %cops = %old_copp;
.Ve
.PP
.Vb 5
\&        # add the correct copp entry for each id except vol/pan
\&        map{ my $n = $_;
\&                        map {   my $id = $_; 
\&                                if (    $state_c{$n}->{vol} eq $id or
\&                                                $state_c{$n}->{pan} eq $id  ){
.Ve
.PP
.Vb 3
\&                                        $copp{$id}->[0] = $old_copp{$id}->[0];
\&                                }
\&                                else {  $copp{$id} = $old_copp{$id} }
.Ve
.PP
.Vb 2
\&                        } @{ $state_c{$_}->{ops} }
\&                } @all_chains;
.Ve
.PP
.Vb 1
\&        # apply ops
.Ve
.PP
.Vb 1
\&        my $did_apply = 0;
.Ve
.PP
.Vb 5
\&        for my $n (@all_chains) { 
\&                for my $id (@{$state_c{$n}->{ops}}){
\&                        $did_apply++ 
\&                                unless $id eq $state_c{$n}->{vol}
\&                                        or $id eq $state_c{$n}->{pan};
.Ve
.PP
.Vb 6
\&                        add_effect({  
\&                                                chain => $cops{$id}->{chain},
\&                                                type => $cops{$id}->{type},
\&                                                cop_id => $id,
\&                                                parent_id => $cops{$id}->{belongs_to},
\&                                                });
.Ve
.PP
.Vb 5
\&                # TODO if parent has a parent, i am a parameter controller controlling
\&                # a parameter controller, and therefore need the -kx switch
\&                }
\&        }
\&        $did_apply and print "########## applied\en\en";
.Ve
.PP
.Vb 1
\&        # $ew->deiconify or $ew->iconify;
.Ve
.PP
}
sub assign_vars {
	# assigns vars in \f(CW@var_list\fR to values from \f(CW$source\fR
	# \f(CW$source\fR can be a :
	#      \- filename or
	#      \- string containing \s-1YAML\s0 data
	#      \- reference to a hash array containing assignments
	#
	# returns a \f(CW$ref\fR containing the retrieved data structure
	\f(CW$debug2\fR and print \*(L"&assign_vars\en\*(R";
	my ($source, \f(CW@vars\fR) = \f(CW@_\fR;
	\f(CW$debug\fR and print \*(L"file: \f(CW$source\fR\en\*(R";
	\f(CW$debug\fR and print \*(L"variable list: \f(CW@vars\fR\en\*(R";
	my \f(CW$ref\fR;
.PP
### figure out what to do with input
.PP
.Vb 2
\&        ## check for State # using Data::Dumper
\&        -f $source and $source eq 'State' and $ref = retrieve($source)
.Ve
.PP
.Vb 1
\&        ## check for a filename
.Ve
.PP
.Vb 1
\&        or -f $source and $ref = yaml_in($source)
.Ve
.PP
.Vb 1
\&        ## check for a string
.Ve
.PP
.Vb 1
\&        or  $source =~ /^\es*---/s and $ref = $yr->($source)
.Ve
.PP
.Vb 1
\&        ## pass a hash_ref to the assigner
.Ve
.PP
.Vb 1
\&        or ref $source and $ref = $source;
.Ve
.PP
#print join $/, \*(L"\s-1VARIABLES\s0\*(R", \f(CW@vars\fR, '';
croak \*(L"expected hash\*(R" if ref \f(CW$ref\fR =~ /HASH/;
#exit;
##
	map{ my ($sigil, \f(CW$identifier\fR) = /(.)(\ew+)/; 
		 my \f(CW$eval\fR = \f(CW$_\fR;
		\f(CW$eval\fR .= q( = );
		\f(CW$eval\fR .= \f(CW$sigil\fR . q({ ) if \f(CW$sigil\fR ne '$';
		\f(CW$eval\fR .= q($ref\->{ );
		\f(CW$eval\fR .= \f(CW$identifier\fR;
		\f(CW$eval\fR .= q( } );
		\f(CW$eval\fR .= qw(} ) if \f(CW$sigil\fR ne '$';
		\f(CW$eval\fR .= q(if defined \f(CW$ref\fR\->{ );
		\f(CW$eval\fR .= \f(CW$identifier\fR;
		\f(CW$eval\fR .= q( }; ) ;
		eval \f(CW$eval\fR or carp \*(L"failed to eval \f(CW$eval:\fR $!\en\*(R";
	} \f(CW@vars\fR;
	\f(CW$ref\fR;
}
sub store_vars {
	# now we will only store in \s-1YAML\s0
	\f(CW$debug2\fR and print \*(L"&store_vars\en\*(R";
	my ($file, \f(CW$var_list\fR) = \f(CW@_\fR;
	\f(CW$file\fR .= '.yaml' unless \f(CW$file\fR =~ /\e.yaml$/;
	\f(CW$debug\fR and print \*(L"file: \f(CW$file\fR\en\*(R";
	my \f(CW@vars\fR = split \*(L"\en\*(R", \f(CW$var_list\fR;
	my \f(CW%state\fR;
	map{ my ($sigil, \f(CW$identifier\fR) = /(.)(\ew+)/; 
		 my \f(CW$eval_string\fR =  q($state{)
							. \f(CW$identifier\fR
							. q(} = \e\e) # double backslash needed
							. \f(CW$_\fR;
	eval($eval_string) or print \*(L"failed to eval \f(CW$eval_string:\fR $!\en\*(R";
	} \f(CW@vars\fR;
	# my \f(CW$result1\fR = store \e%state, \f(CW$file\fR; # \s-1OLD\s0 \s-1METHOD\s0
	my \f(CW$yamlout\fR = yaml_out(\e%state);
	\f(CW$yamlout\fR > io \f(CW$file\fR;
.PP
}
sub yaml_out {
	\f(CW$debug2\fR and print \*(L"&yaml_out\en\*(R";
	my ($data_ref) = shift; 
	my \f(CW$type\fR = ref \f(CW$data_ref\fR;
	\f(CW$debug\fR and print \*(L"data ref type: \f(CW$type\fR\en \*(R"; 
	croak \*(L"attempting to code wrong data type: \f(CW$type\fR\*(R"
		if \f(CW$type\fR !~ /HASH|ARRAY/;
#	carp \*(L"can't yaml-out a Scalar!!\en\*(R" if ref \f(CW$data_ref\fR eq '\s-1SCALAR\s0';
	my \f(CW$output\fR;
    \f(CW$yw\fR\->write( \f(CW$data_ref\fR, \e$output ); 
	\f(CW$output\fR;
}
sub yaml_in {
	my \f(CW$file\fR = shift;
	my \f(CW$yaml\fR = io($file)\->all;
	\f(CW$yr\fR\->read( \f(CW$yaml\fR ); # returns ref
}
.PP
sub arm_mark { 
	if ($markers_armed) {
		\f(CW$markers_armed\fR = 0;
		map{$time_marks[$_]\->configure( \-background => \f(CW$old_bg\fR) unless ! \f(CW$marks\fR[$_] } 1..$#time_marks ;
	}
	else{
		\f(CW$markers_armed\fR = 1;
		map{$_\->configure( \-background => 'lightblue') } \f(CW@time_marks\fR[1..$#time_marks] ;
	}
}
sub colonize { # convert seconds to minutes:seconds 
	my \f(CW$sec\fR = shift;
	my \f(CW$min\fR = int ($sec / 60);
	\f(CW$sec\fR = \f(CW$sec\fR % 60;
	\f(CW$sec\fR = \*(L"0$sec\*(R" if \f(CW$sec\fR < 10;
	qq($min:$sec);
}
sub mark {
	my \f(CW$marker\fR = shift;
	# print \*(L"my marker is \f(CW$_\fR\en\*(R";
	# record without arming if marker undefined
	if ($markers_armed or ! \f(CW$marks\fR[$marker]){  
		my \f(CW$here\fR = eval_iam(\*(L"cs\-get\-position\*(R");
		return if ! \f(CW$here\fR;
		\f(CW$marks\fR[$marker] = \f(CW$here\fR;
		my \f(CW$widget\fR = \f(CW$time_marks\fR[$marker];
		\f(CW$widget\fR\->configure(
			\-text => colonize($here),
			\-background => \f(CW$old_bg\fR,
		);
		if ($markers_armed){ arm_mark } # disarm
	}
	else{ 
		return if \fIreally_recording()\fR;
		eval_iam(qq(cs\-set\-position \f(CW$marks\fR[$marker]));
	#	\fIupdate_clock()\fR;
	#	\fIstart_clock()\fR;
	}
}
.PP
sub strip_all{ blank_lines( strip_comments(@_) ) }
.PP
sub strip_blank_lines {
	map{ s/\en(\es*\en)+/\en/sg } \f(CW@_\fR;
	\f(CW@_\fR;
.PP
}
.PP
sub strip_comments { #  
	map{ s/#.*$//mg; } \f(CW@_\fR;
	\f(CW@_\fR
} 
#print strip_comments (\*(L"$a +~ line of \f(CW%code\fR # followed by comments\*(R"); 
.PP
sub remove_spaces {                                                             
        my \f(CW$entry\fR = shift;                                                      
        # remove leading and trailing spaces                                    
.PP
.Vb 2
\&        $entry =~ s/^\es*//;                                                     
\&        $entry =~ s/\es*$//;
.Ve
.PP
.Vb 1
\&        # convert other spaces to underscores
.Ve
.PP
.Vb 3
\&        $entry =~ s/\es+/_/g;                                                    
\&        $entry;                                                                 
\&}
.Ve
.PP
## The following methods belong to the Graphical interface class
.PP
package UI::Graphical;
our \f(CW@ISA\fR = '\s-1UI\s0';
use Carp;
sub hello {\*(L"make a window\*(R";}
.PP
#sub new { my \f(CW$class\fR = shift; return bless { \f(CW@_\fR }, \f(CW$class\fR; }
.PP
sub session_label_configure{ session_label_configure(@_)}
sub length_display{ \f(CW$setup_length\fR\->configure(\-text => colonize \f(CW$length\fR) };
sub clock_display { \f(CW$clock\fR\->configure(\-text => colonize( 0) )}
sub manifest { \f(CW$ew\fR\->\fIdeiconify()\fR }
.PP
sub loop {
	\fIinit_gui()\fR; 
	\fItransport_gui()\fR;
	\fIoid_gui()\fR;
	\fItime_gui()\fR;
	print &config; exit;
	\fIshello()\fR;
	\fIsession_init()\fR, load_session({create => \f(CW$opts\fR{c}}) if \f(CW$session_name\fR;
	MainLoop;
}
.PP
## gui handling
.PP
sub init_gui {
.PP
.Vb 1
\&        $debug2 and print "&init_gui\en";
.Ve
.PP
### 	Tk root window layout
.PP
.Vb 2
\&        $mw = MainWindow->new; 
\&        $mw->title("Tk Ecmd");
.Ve
.PP
.Vb 1
\&        ### init effect window
.Ve
.PP
.Vb 3
\&        $ew = $mw->Toplevel;
\&        $ew->title("Effect Window");
\&        $ew->withdraw;
.Ve
.PP
.Vb 12
\&        $canvas = $ew->Scrolled('Canvas')->pack;
\&        $canvas->configure(
\&                scrollregion =>[2,2,10000,2000],
\&                -width => 900,
\&                -height => 600, 
\&                );
\&#               scrollregion =>[2,2,10000,2000],
\&#               -width => 1000,
\&#               -height => 4000,        
\&        $effect_frame = $canvas->Frame;
\&        my $id = $canvas->createWindow(30,30, -window => $effect_frame,
\&                                                                                        -anchor => 'nw');
.Ve
.PP
.Vb 9
\&        $session_label = $mw->Label->pack(-fill => 'both');
\&        $old_bg = $session_label->cget('-background');
\&        $time_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $transport_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $oid_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $clock_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $track_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $take_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $take_label = $take_frame->Menubutton(-text => "Group",-tearoff => 0,)->pack(-side => 'left');
.Ve
.PP
.Vb 5
\&        $add_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $perl_eval_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $iam_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&        $load_frame = $mw->Frame->pack(-side => 'bottom', -fill => 'both');
\&#       my $blank = $mw->Label->pack(-side => 'left');
.Ve
.PP
.Vb 6
\&        $sn_label = $load_frame->Label(-text => "Enter session name:")->pack(-side => 'left');
\&        $sn_text = $load_frame->Entry(-textvariable => \e$session, -width => 45)->pack(-side => 'left');
\&        $sn_load = $load_frame->Button->pack(-side => 'left');;
\&#       $sn_load_nostate = $load_frame->Button->pack(-side => 'left');;
\&        $sn_new = $load_frame->Button->pack(-side => 'left');;
\&        $sn_quit = $load_frame->Button->pack(-side => 'left');
.Ve
.PP
.Vb 7
\&        $build_track_label = $add_frame->Label(-text => "Track")->pack(-side => 'left');
\&        $build_track_text = $add_frame->Entry(-textvariable => \e$track_name, -width => 12)->pack(-side => 'left');
\&        $build_track_rec_label = $add_frame->Label(-text => "REC")->pack(-side => 'left');
\&        $build_track_rec_text = $add_frame->Entry(-textvariable => \e$ch_r, -width => 2)->pack(-side => 'left');
\&        $build_track_mon_label = $add_frame->Label(-text => "MON")->pack(-side => 'left');
\&        $build_track_mon_text = $add_frame->Entry(-textvariable => \e$ch_m, -width => 2)->pack(-side => 'left');
\&        $build_track_add = $add_frame->Button->pack(-side => 'left');;
.Ve
.PP
.Vb 22
\&        $sn_load->configure(
\&                -text => 'Load',
\&                -command => \e&load_session,
\&                );
\&        $sn_new->configure( 
\&                -text => 'New',
\&                -command => sub { load_session({create => 1}) },
\&                );
\&        $sn_quit->configure(-text => "Quit",
\&                 -command => sub { 
\&                                return if transport_running();
\&                                save_state(join_path(&session_dir,$state_store_file)) 
\&                                        if session_dir();
\&                $debug2 and print "\e%state_c\en================\en", &yaml_out(\e%state_c);
\&                $debug2 and print "\e%state_t\en================\en", &yaml_out(\e%state_t);
\&                $debug2 and print "\e%copp\en================\en", &yaml_out(\e%copp);
\&                $debug2 and print "\e%cops\en================\en", &yaml_out(\e%cops);
\&                $debug2 and print "\e%pre_output\en================\en", &yaml_out(\e%pre_output); 
\&                $debug2 and print "\e%post_input\en================\en", &yaml_out(\e%post_input);
\&                exit;
\&                                 }
\&                                );
.Ve
.PP
.Vb 4
\&        $build_track_add->configure( 
\&                        -text => 'Add',
\&                        -command => sub { add_track($track_name) }
\&        );
.Ve
.PP
.Vb 2
\&                        );
\&=cut
.Ve
.PP
.Vb 5
\&        my @labels = 
\&                qw(Track Version Status Rec Mon Volume Cut Unity Pan Center Effects);
\&        my @widgets;
\&        map{ push @widgets, $track_frame->Label(-text => $_)  } @labels;
\&        $widgets[0]->grid(@widgets[1..$#widgets]);
.Ve
.PP
.Vb 20
\&        $iam_label = $iam_frame->Label(-text => "IAM Command")
\&                ->pack(-side => 'left');;
\&        $iam_text = $iam_frame->Entry( 
\&                -textvariable => \e$iam, -width => 65)
\&                ->pack(-side => 'left');;
\&        $iam_execute = $iam_frame->Button(
\&                        -text => 'Execute',
\&                        -command => sub { print eval_iam($iam), "\en" }
\&                )->pack(-side => 'left');;
\&        my $perl_eval;
\&        my $perl_eval_label = $perl_eval_frame->Label(
\&                -text => "Perl Command")
\&                ->pack(-side => 'left');;
\&        my $perl_eval_text = $perl_eval_frame->Entry(
\&                -textvariable => \e$perl_eval, -width => 65)
\&                ->pack(-side => 'left');;
\&        my $perl_eval_execute = $perl_eval_frame->Button(
\&                        -text => 'Execute',
\&                        -command => sub { eval $perl_eval  }
\&                )->pack(-side => 'left');;
.Ve
.PP
}
sub transport_gui {
.PP
.Vb 11
\&        $transport_label = $transport_frame->Label(
\&                -text => 'TRANSPORT',
\&                -width => 12,
\&                )->pack(-side => 'left');;
\&        $transport_setup_and_connect  = $transport_frame->Button->pack(-side => 'left');;
\&        $transport_start = $transport_frame->Button->pack(-side => 'left');
\&        $transport_stop = $transport_frame->Button->pack(-side => 'left');
\&        $transport_setup = $transport_frame->Button->pack(-side => 'left');;
\&        $transport_connect = $transport_frame->Button->pack(-side => 'left');;
\&        $transport_disconnect = $transport_frame->Button->pack(-side => 'left');;
\&        $transport_new = $transport_frame->Button->pack(-side => 'left');;
.Ve
.PP
.Vb 40
\&        $transport_stop->configure(-text => "Stop",
\&        -command => sub { 
\&                                        stop_transport();
\&                                }
\&                );
\&        $transport_start->configure(
\&                -text => "Start!",
\&                -command => sub { 
\&                return if transport_running();
\&                if ( really_recording ) {
\&                        session_label_configure(-background => 'lightpink') 
\&                }
\&                else {
\&                        session_label_configure(-background => 'lightgreen') 
\&                }
\&                start_transport();
\&                                });
\&        $transport_setup_and_connect->configure(
\&                        -text => 'Generate and connect',
\&                        -command => sub {&setup_transport; &connect_transport}
\&                                                 );
\&        $transport_setup->configure(
\&                        -text => 'Generate chain setup',
\&                        -command => \e&setup_transport,
\&                                                 );
\&        $transport_connect->configure(
\&                        -text => 'Connect chain setup',
\&                        -command => \e&connect_transport,
\&                                                 );
\&        $transport_disconnect->configure(
\&                        -text => 'Disconnect setup',
\&                        -command => \e&disconnect_transport,
\&                                                );
\&        $transport_new->configure(
\&                        -text => 'New Engine',
\&                        -command => \e&new_engine,
\&                                                 );
\&}
\&sub time_gui {
\&        $debug2 and print "&time_gui\en";
.Ve
.PP
.Vb 15
\&        my $time_label = $clock_frame->Label(
\&                -text => 'TIME', 
\&                -width => 12);
\&        $clock = $clock_frame->Label(
\&                -text => '0:00', 
\&                -width => 8,
\&                -background => 'orange',
\&                );
\&        my $length_label = $clock_frame->Label(
\&                -text => 'LENGTH',
\&                -width => 10,
\&                );
\&        $setup_length = $clock_frame->Label(
\&        #       -width => 8,
\&                );
.Ve
.PP
.Vb 3
\&        for my $w ($time_label, $clock, $length_label, $setup_length) {
\&                $w->pack(-side => 'left');      
\&        }
.Ve
.PP
.Vb 7
\&        my $mark_frame = $time_frame->Frame->pack(
\&                -side => 'bottom', 
\&                -fill => 'both');
\&        my $fast_frame = $time_frame->Frame->pack(
\&                -side => 'bottom', 
\&                -fill => 'both');
\&        # jump
.Ve
.PP
.Vb 22
\&        my $jump_label = $fast_frame->Label(-text => q(JUMP), -width => 12);
\&        my $mark_label = $mark_frame->Label(-text => q(MARK), -width => 12);
\&        my @pluses = (1, 5, 10, 30, 60);
\&        my @minuses = map{ - $_ } reverse @pluses;
\&        my @fw = map{ my $d = $_; $fast_frame->Button(
\&                        -text => $d,
\&                        -command => sub { jump($d) },
\&                        )
\&                }  @pluses ;
\&        my @rew = map{ my $d = $_; $fast_frame->Button(
\&                        -text => $d,
\&                        -command => sub { jump($d) },
\&                        )
\&                }  @minuses ;
\&        my $beg = $fast_frame->Button(
\&                        -text => 'Beg',
\&                        -command => \eto_start,
\&                        );
\&        my $end = $fast_frame->Button(
\&                        -text => 'End',
\&                        -command => \eto_end,
\&                        );
.Ve
.PP
.Vb 6
\&        $time_step = $fast_frame->Button( 
\&                        -text => 'Sec',
\&                        );
\&                for my $w($jump_label, @rew, $beg, $time_step, $end, @fw){
\&                        $w->pack(-side => 'left')
\&                }
.Ve
.PP
.Vb 1
\&        $time_step->configure (-command => \etoggle_unit);
.Ve
.PP
.Vb 1
\&        # Marks
.Ve
.PP
.Vb 18
\&        my @label_and_arm;
\&        push @label_and_arm, $mark_label;       
\&        push @label_and_arm, $mark_frame->Button(
\&                -text => 'Set',
\&                -command => sub { arm_mark },
\&        );
\&        my $marks = 18; # number of marker buttons
\&        my @m = (1..$marks);
\&        my $label = qw(A);
\&        map { push @time_marks, $mark_frame->Button( 
\&                -text => $_,
\&                -command => sub { mark(eval $_)},
\&                -background => $marks[$_] ? $old_bg : 'lightblue',
\&                ) } @m;
\&        # map { $time_marks[$_]->configure( -command => sub { # mark($_)} ) } @m[1..$#m];
\&        for my $m (@m) {
\&                $time_marks[$m]->configure( -command => sub { mark($m)} )
\&                        unless ! defined $time_marks[$m];
.Ve
.PP
.Vb 8
\&                ;
\&        }
\&        #$time_marks[3]->configure( -background => 'orange' );
\&#        map { $time_marks[$_]->configure(-background => 'orange')} @m;
\&        for my $w (@label_and_arm, @time_marks){
\&                $w->pack(-side => 'left')
\&        }
\&#       $time_marks[0]->grid(@time_marks[@m]);
.Ve
.PP
}
sub oid_gui {
	\f(CW$debug2\fR and print \*(L"&oid_gui\en\*(R";
	my \f(CW$outputs\fR = \f(CW$oid_frame\fR\->Label(\-text => '\s-1OUTPUTS\s0', \-width => 12);
	my \f(CW@oid_name\fR;
	for my \f(CW$oid\fR ( \f(CW@oids\fR ){
		# print \*(L"gui oid name: \f(CW$oid\fR\->{name} status: \f(CW$oid_status\fR{$oid\->{name}}\en\*(R";
		next if \f(CW$oid\fR\->{name} =~ m/setup/;
		push \f(CW@oid_name\fR, \f(CW$oid\fR\->{name};
.PP
.Vb 20
\&                my $oid_button = $oid_frame->Button( 
\&                        -text => ucfirst $oid->{name},
\&                        -background => 
\&                                $oid_status{$oid->{name}} ?  'AntiqueWhite' : $old_bg,
\&                        -activebackground => 
\&                                $oid_status{$oid->{name}} ? 'AntiqueWhite' : $old_bg
\&                );
\&                push @widget_o, $oid_button;
\&                $widget_o{$oid->{name}} = $oid_button;
\&        }
\&        for my $i (0..$#widget_o) {
\&                $widget_o[$i]->configure(
\&                        -command => sub { 
\&                print "but oid name: $oid_name[$i] status: $oid_status{$oid_name[$i]}\en";
\&                                $oid_status{$oid_name[$i]} = !  $oid_status{$oid_name[$i]};
\&                print "but oid name: $oid_name[$i] status: $oid_status{$oid_name[$i]}\en";
\&                                $widget_o[$i]->configure( -background => 
\&                                        $oid_status{$oid_name[$i]} ?  'AntiqueWhite' : $old_bg ,
\&                        -activebackground => 
\&                                        $oid_status{$oid_name[$i]} ? 'AntiqueWhite' : $old_bg
.Ve
.PP
.Vb 4
\&                                        );
\&                        });
\&        }
\&        my $toggle_jack = $oid_frame->Button;
.Ve
.PP
.Vb 5
\&        $toggle_jack->configure(
\&                -text => q(Jack ON/OFF),
\&                -command => sub {
\&                        my $color = $toggle_jack->cget( -background );
\&                                if ($color eq q(lightblue) ){
.Ve
.PP
.Vb 1
\&                                        # jack is on, turn it off
.Ve
.PP
.Vb 5
\&                                        convert_to_alsa();
\&                                        paint_button($toggle_jack, $old_bg);
\&                                        $jack_on = 0;
\&                                }
\&                                else {
.Ve
.PP
.Vb 7
\&                                        convert_to_jack();
\&                                        paint_button($toggle_jack, q(lightblue));
\&                                        $jack_on = 1;
\&                                }
\&                        }
\&                );
\&        push @widget_o, $toggle_jack; # since no one else uses this array
.Ve
.PP
.Vb 1
\&        map { $_ -> pack(-side => 'left') } ($outputs, @widget_o);
.Ve
.PP
}
sub paint_button {
	my ($button, \f(CW$color\fR) = \f(CW@_\fR;
	\f(CW$button\fR\->configure(\-background => \f(CW$color\fR,
						\-activebackground => \f(CW$color\fR);
}
sub flash_ready {
	my \f(CW$color\fR;
		if (@record ){
			\f(CW$color\fR = 'lightpink'; # live recording
		} elsif ( really_recording ){  # mixing only
			\f(CW$color\fR = 'yellow';
		} else {  \f(CW$color\fR = 'lightgreen'; }; # just playback
.PP
.Vb 9
\&        $debug and print "flash color: $color\en";
\&        _display(-background => $color);
\&        $->after(10000, 
\&                sub{ length_display(-background => $old_bg) }
\&        );
\&}
\&sub take_gui {
\&        my $t = shift;
\&        #my $debug = 1;
.Ve
.PP
.Vb 8
\&        $debug2 and print "&take_gui\en";
\&                my $tname = $alias{$t} ? $alias{$t} : $t;
\&                my $name = $take_frame->Menubutton(
\&                                -text => ucfirst $tname,
\&                                -tearoff =>0,
\&                        )->pack(-side => 'left');
\&                push @widget_t, $name;
\&        $debug and print "=============\en\e@widget_t\en",yaml_out(\e@widget_t);
.Ve
.PP
.Vb 1
\&                if ($t != 1) { # do not add REC command for Mixdown group MIX
.Ve
.PP
.Vb 11
\&                $name->AddItems([
\&                        'command' => $UI::REC,
\&                        -background => $old_bg,
\&                        -command => sub { 
\&                                no strict qw(vars);
\&                                defined $my_t or my $my_t = $t;
\&                                use strict qw(vars);
\&                                select_take ($my_t, qq(REC) );
\&                                }
\&                        ]);
\&                }
.Ve
.PP
.Vb 19
\&                $name->AddItems([
\&                        'command' => $UI::MON,
\&                        -background => $old_bg,
\&                        -command => sub {
\&                                no strict qw(vars);
\&                                defined $my_t or my $my_t = $t;
\&                                use strict qw(vars);
\&                                select_take($my_t, qq(MON)); 
\&                                }
\&                        ]);
\&                $name->AddItems([
\&                        'command' => $UI::MUTE,
\&                        -background => $old_bg,
\&                        -command => sub {
\&                                no strict qw(vars);
\&                                defined $my_t or my $my_t = $t;
\&                                use strict qw(vars);
\&                                select_take($my_t, qq(MUTE)); 
\&                                }
.Ve
.PP
.Vb 1
\&                ]);
.Ve
.PP
}
sub global_version_buttons {
#	( map{ \f(CW$_\fR\->destroy } \f(CW@global_version_buttons\fR ) if \f(CW@global_version_buttons\fR; 
    my \f(CW@children\fR = \f(CW$widget_t\fR[1]\->children;
	for (@children) {
		\f(CW$_\fR\->cget(\-value) and \f(CW$_\fR\->destroy;
	}; # should remove menubuttons
.PP
.Vb 20
\&        @global_version_buttons = ();
\&        $debug and print "making global version buttons range:", join ' ',1..$last_version, " \en";
\&        for my $v (undef, 1..$last_version) {
\&                no warnings;
\&                next unless grep{  grep{ $v == $_ } @{ $state_c{$_}->{versions} } }
\&                        grep{ $_ != 1 } @all_chains; # MIX 
\&                use warnings;
\&                push @global_version_buttons,
\&                        $widget_t[1]->radiobutton(
\&                                ###  HARDCODED, second take widget
\&                                -label => ($v ? $v : ''),
\&                                -variable => \e$monitor_version,
\&                                -value => $v,
\&                                -command => sub { 
\&                                        $state_t{2}->{rw} = $UI::MON; ### HARDCODED SECOND TAKE; MIX
\&                                        mon_vert($v);  # select this version
\&                                        setup_transport(); 
\&                                        connect_transport();
\&                                        refresh();
\&                                        }
.Ve
.PP
.Vb 4
\&                                        );
\&        }
\&}
\&sub track_gui { # nearly 300 lines!
.Ve
.PP
.Vb 23
\&        my $n = shift; # chain index is lexicalized, will remain static in callbacks
\&                                        # my $j is effect index
\&        my ($name, $version, $rw, $ch_r, $ch_m, $vol, $mute, $solo, $unity, $pan, $center);
\&        my $this_take = $t; 
\&        $debug2 and print "&track_gui\en";
\&        my $stub = $state_c{$n}->{active};
\&        $name = $track_frame->Label(
\&                        -text => $state_c{$n}->{file},
\&                        -justify => 'left');
\&        $version = $track_frame->Menubutton( 
\&                                        -text => $stub,
\&                                        -tearoff => 0);
\&        for my $v (undef, @{$state_c{$n}->{versions}}) {
\&                                        $version->radiobutton(
\&                                                -label => ($v ? $v: ''),
\&                                                -variable => \e$state_c{$n}->{active},
\&                                                -value => $v,
\&                                                -command => 
\&                sub { $version->configure(-text=> selected_version($n) ) 
\&        #               unless rec_status($n) eq $UI::REC
\&                        }
\&                                        );
\&        }
.Ve
.PP
.Vb 34
\&        $ch_r = $track_frame->Menubutton(
\&                                        -textvariable => \e$state_c{$n}->{ch_r},
\&                                        -tearoff => 0,
\&                                );
\&                        if ( $n != 1 ) { # for all but Mixdown track MIX
\&                                for my $v (1..$tk_input_channels) {
\&                                        $ch_r->radiobutton(
\&                                                -label => $v,
\&                                                -variable => \e$state_c{$n}->{ch_r},
\&                                                -value => $v,
\&                                                -command => sub { 
\&                                                        $state_c{$n}->{rw} = $UI::REC;
\&                                                        refresh() }
\&                                                )
\&                                }
\&                        }
\&        $ch_m = $track_frame->Menubutton(
\&                                        -textvariable => \e$state_c{$n}->{ch_m},
\&                                        -tearoff => 0,
\&                                );
\&                                for my $v (1..10) {
\&                                        $ch_m->radiobutton(
\&                                                -label => $v,
\&                                                -variable => \e$state_c{$n}->{ch_m},
\&                                                -value => $v,
\&                                                -command => sub { 
\&                                                        $state_c{$n}->{rw} = $UI::MON;
\&                                                        refresh_c($n) }
\&                                                )
\&                                }
\&        $rw = $track_frame->Menubutton(
\&                -text => $state_c{$n}->{rw},
\&                -tearoff => 0,
\&        );
.Ve
.PP
.Vb 23
\&        my @items = (
\&                        [ 'command' => $UI::REC,
\&                                -foreground => 'red',
\&                                -command  => sub { 
\&                                        $state_c{$n}->{rw} = $UI::REC;
\&                                        refresh();
\&                                        }
\&                        ],
\&                        [ 'command' => $UI::MON,
\&                                -command  => sub { 
\&                                        $state_c{$n}->{rw} = $UI::MON;
\&                                        refresh();
\&                                        }
\&                        ],
\&                        [ 'command' => $UI::MUTE, 
\&                                -command  => sub { 
\&                                        $state_c{$n}->{rw} = $UI::MUTE;
\&                                        refresh();
\&                                        }
\&                        ],
\&                );
\&        map{$rw->AddItems($_) unless $n == 1} @items; # MIX CONDITIONAL
\&        $state_c{$n}->{rw} = $UI::MON if $n == 1;          # MIX
.Ve
.PP
.Vb 1
\&   ## XXX general code mixed with GUI code
.Ve
.PP
.Vb 1
\&        # Volume
.Ve
.PP
.Vb 2
\&        my $p_num = 0; # needed when using parameter controllers
\&        my $vol_id = add_volume_control($n);
.Ve
.PP
.Vb 8
\&        $debug and print "vol cop_id: $vol_id\en";
\&        my %p = (       parent => \e$track_frame,
\&                        chain  => $n,
\&                        type => 'ea',
\&                        cop_id => $vol_id,
\&                        p_num           => $p_num,
\&                        length => 300, 
\&                        );
.Ve
.PP
.Vb 2
\&         $debug and do {my %q = %p; delete $q{parent}; print
\&         "x=============\en%p\en",yaml_out(\e%q)};
.Ve
.PP
.Vb 2
\&        $vol = make_scale ( \e%p );
\&        # Mute
.Ve
.PP
.Vb 21
\&        $mute->configure( -command => sub { toggle_muting($mute, $n) });
\&=cut;
\&        $mute = $track_frame->Button(
\&                        -command => sub { 
\&                                if ($copp{$vol_id}->[0]) {  # non-zero volume
\&                                        $old_vol{$n}=$copp{$vol_id}->[0];
\&                                        $copp{$vol_id}->[0] = 0;
\&                                        effect_update($p{chain}, $p{cop_id}, $p{p_num}, 0);
\&                                        $mute->configure(-background => 'brown');
\&                                        $mute->configure(-activebackground => 'brown');
\&                                }
\&                                else {
\&                                        $copp{$vol_id}->[0] = $old_vol{$n};
\&                                        effect_update($p{chain}, $p{cop_id}, $p{p_num}, 
\&                                                $old_vol{$n});
\&                                        $old_vol{$n} = 0;
\&                                        $mute->configure(-background => $old_bg);
\&                                        $mute->configure(-activebackground => $old_bg);
\&                                }
\&                        }       
\&          );
.Ve
.PP
.Vb 1
\&        # Solo
.Ve
.PP
.Vb 3
\&        $solo = $track_frame->Button;
\&        my @muted;
\&        $solo->configure( -command => sub {
.Ve
.PP
.Vb 1
\&                # do nothing if mix track
.Ve
.PP
.Vb 1
\&                return if $n == 1; MIX
.Ve
.PP
.Vb 1
\&                # do nothing if setup not connected
.Ve
.PP
.Vb 1
\&                return if ! grep{/$session_name/} eval_iam(q(cs-connected));
.Ve
.PP
.Vb 1
\&                # do nothing if someone else is soloing;
.Ve
.PP
.Vb 4
\&                return if grep{ is_soloing($_) } grep {$_ != $n} @all_chains; # but some may
\&                                                                               # not be in
\&                                                                                                                                           # chain
\&                                                                                                                                           # setup
.Ve
.PP
.Vb 1
\&                # restore prior mute settings if I had been soloing
.Ve
.PP
.Vb 1
\&                if (is_soloing($n) ) {
.Ve
.PP
.Vb 2
\&                        $solo->configure(-foreground => $old_bg );
\&                        $solo->configure(-activeforeground => $old_bg );
.Ve
.PP
.Vb 3
\&                        map{ toggle_mute($_) if $muted[$_] != is_muted($_) } 
\&                                grep{$_ != 1} @all_chains; # MIX
\&                }
.Ve
.PP
.Vb 1
\&                # otherwise save muted status for each track and mute all
.Ve
.PP
.Vb 2
\&                else {
\&                        map{ $mute($_) = is_muted($_) } grep{$_ != 1} @all_chains; # MIX
.Ve
.PP
.Vb 5
\&                        map{ toggle_mute($_) } 
\&                        grep {! is_muted($_) } 
\&                        grep {$_ != $n} 
\&                        grep {$_ != 1} 
\&                        @all_chains;
.Ve
.PP
.Vb 1
\&                        is_muted($n) and toggle_mute($n);
.Ve
.PP
.Vb 2
\&                        $solo->configure(-foreground => q(yellow) );
\&                        $solo->configure(-activeforeground => q(yellow) );
.Ve
.PP
.Vb 2
\&                }
\&        });
.Ve
.SH "NAME"
:: \- Perl extensions for multitrack audio
recording and processing by Ecasound
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Audio::Ecasound::Flow;
.Ve
.PP
.Vb 1
\&  my $ui = UI->new("tk");
.Ve
.PP
.Vb 1
\&                or
.Ve
.PP
.Vb 1
\&  my $ui = UI->new("text");
.Ve
.PP
.Vb 1
\&        my %options = (
.Ve
.PP
.Vb 6
\&                        session => 'Night at Carnegie',
\&                        create => 1,
\&                        effects => 'force-reload',
\&                        track_state   => 'ignore',     
\&                        effect_state   => 'ignore',     
\&                        ) ;
.Ve
.PP
.Vb 1
\&        $ui->main(%options);
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.Vb 3
\&        Builds on the Audio::Ecasound interface to the 
\&        Ecasound audio processing engine to facilitate
\&        multitrack audio recording. Additions include:
.Ve
.PP
.Vb 2
\&        - Functions for generating chain setups, managing wav
\&        files, handling persistent configuration data.
.Ve
.PP
.Vb 1
\&        - Useful text-mode and Tk user interfaces
.Ve
.PP
.Vb 2
\&        - A foundation for high-level abstractions such 
\&          as track, group, effect, mark, etc.
.Ve
.PP
.Vb 5
\&        Hash data structures representing system state are
\&        serialized to YAML and written to file. 
\&        The Git version control system cheaply provides 
\&        infrastructure for switching among various parameter
\&        sets.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Stub documentation for Audio::Ecasound::Flow, created by h2xs. It looks like the
author of the extension was negligent enough to leave the stub
unedited.
.PP
Blah blah blah.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Mention other useful documentation such as the documentation of
related modules or operating system documentation (such as man pages
in \s-1UNIX\s0), or any relevant external documentation such as RFCs or
standards.
.PP
If you have a mailing list set up for your module, mention it here.
.PP
If you have a web site set up for your module, mention it here.
.SH "AUTHOR"
.IX Header "AUTHOR"
Joel Roth, <jroth@dsl\-verizon.net>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2007 by Joel Roth
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
.PP
_\|_END_\|_
