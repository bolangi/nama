sub load_session {
	my $hash = shift;
	$debug2 and print "&load_session\n";
	$debug and print "\$session: $session name: $hash->{name} create: $hash->{create}\n";
	return unless $hash->{name} or $session;

	# we could be called from Tk with variable $session _or_
	# called with a hash with 'name' and 'create' fields.
	
	$session = remove_spaces($session); # internal spaces to underscores
	$session_name = $hash->{name} ? $hash->{name} : $session;
	$hash->{create} and 
		print ("Creating directories....\n"),
		map{create_dir($_)} &this_wav_dir, &session_dir;
=comment 
	# OPEN EDITOR TODO
	my $new_file = join_path ($ecmd_home, $session_name, $parameters);
	open PARAMS, ">$new_file" or carp "couldn't open $new_file for write: $!\n";
	print PARAMS $configuration;
	close PARAMS;
	system "$ENV{EDITOR} $new_file" if $ENV{EDITOR};
=cut
	read_config();
	initialize_session_data();
	remove_small_wavs(); 
	print "reached here!!!\n";
	retrieve_state_storable(join_path(&session_dir,$state_store_file)) ;
		#unless $opts{m} or $state_store_file =~ /.yaml$/;
	#retrieve_state (join_path(&session_dir,$state_store_file)) 
		#unless $opts{m} or $state_store_file !~ /.yaml$/;
	add_mix_track(), dig_ruins() unless scalar @all_chains;
	$ui->global_version_buttons();
}
#The mix track will always be track index 1 i.e. $state_c{$n}
# for $n = 1, And take index 1.

sub initialize_session_data {
	$debug2 and print "&initialize_session_data\n";

	return if transport_running();
	$ui->session_label_configure(
		-text => uc $session_name, 
		-background => 'lightyellow',
		); 

	# assign_vars($session_init_file, @session_vars);

	$last_version = 0;
	%track_names = ();
	%state_c        = ();   #  chain related state
	%state_t        = ();   # take related state
	%cops        = ();   
	$cop_id           = "A"; # autoincrement
	%copp           = ();    # chain operator parameters, dynamic
	                        # indexed by {$id}->[$param_no]
							# and others
	%old_vol = ();

	%take        = (); # the group a chain belongs to # by chain_id
	%chain       = (); # the chain_id corresponding to a track name
	#%alias      = ();  # a way of naming takes

	@takes       = ();  
	@record		= ();
	@monitor	= ();
	@mute = (); 
	@all_chains  = (); # indices of all chains
	@input_chains = ();
	@output_chains = ();

	$i           = 0;  # chain counter
	$t           = 0;  # take counter

	%widget_c = ();
	@widget_t = ();
	%widget_e = ();
	

	# time related
	
	$markers_armed = 0;
	@marks = ();

	
	# volume settings
	
	%old_vol = ();

	# $is_armed = 0;

$ui->destroy_widgets();

increment_take(); 

$ui->take_gui($t);

}
## track and wav file handling

sub add_track {
	$debug2 and print "&add_track\n";
	local $debug = 0;
	return 0 if transport_running();
	my $name = shift;
	# new scoping code!
	###### old, deprecated  $name and my $track_name = $name; 
	# otherwise we use $trackname from previous scope
	
	local $track_name = $name if $name;
	if ($track_names{$track_name}){
		$debug and carp ("Track name in use\n");
		return 0;
	}
	$track_name = remove_spaces($track_name);
	$state_t{$t}->{rw} = "REC";
	$track_names{$track_name}++;
	$i++; # global variable track counter
	register_track($i, $track_name, $ch_r, $ch_m);
	find_wavs($i);
	#set_active_version($i) if ! defined $state_c{$i}->{active};
	$track_name = $ch_m = $ch_r = undef;

	$state_c{$i}->{ops} = [] if ! defined $state_c{$i}->{ops};
	$state_c{$i}->{rw} = "REC" if ! defined $state_c{$i}->{rw};
	$ui->track_gui($i);
	return 1;
}
sub add_mix_track {
	# return if $opts{m} or ! -e # join_path(&session_dir,$state_store_file);
	add_track($mixname) ;
	# the variable $t magically increments
	$state_t{$t}->{rw} = "MUTE"; 
	new_take();
	$state_t{$t}->{rw} = "MON";
}
sub mix_suffix {
	my $stub = shift;
	$stub eq $mixname ? ' (mix)' : ''
}
sub restore_track {
	$debug2 and print "&restore_track\n";
	my $n = shift;
	find_wavs($n);
	$ui->track_gui($n), $ui->refresh();
}
sub register_track {
	$debug2 and print "&register_track\n";
	my ($i, $name, $ch_r, $ch_m) = @_;
  	push @all_chains, $i;
  	# print "ALL chains: @all_chains\n";
	$take{$i} = $t;
	$chain{$name} = $i;
	$state_c{$i}->{rw} = "REC";
	$state_c{$i}->{ch_m} = $ch_m;
	$state_c{$i}->{ch_r} = $ch_r;
	$name =~ s/\.wav$//;
	$state_c{$i}->{file} = $name;
	# print SESSION join ";", $name, $ch_m, $ch_r;
	# print SESSION "\n";
}
