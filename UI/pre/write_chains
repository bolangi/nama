
inputs---->{device_name}->[chain_id1, chain_id2,... ]
           {file}->$state_c{$n}->{file} }->[chain_id1, chain_id2]
	       {cooked}->$n->[chain_ida chain_idb,...      ]
	       {mixed}->$n->[chain_ida chain_idb,...      ]


outputs--->device->{$name}[chain_id1, chain_id2,...]
        |_>file->{ $file }->[chain_id1, chain_id2]
		|->loop_id->[ chain_id ]

intermediate->chain_id->"chain operators and routing, etc."

=cut
sub write_chains {
	$debug2 and print "&write_chains\n";

	# the mixchain is usually '1', so that effects applied to 
	# track 1 (project_name) affect the mix.
	#
	# but when playing back a mix, we want mixchain to be 
	# something else
	
	my $mixchain = rec_status(1) eq "MON"
						? $mixchain_aux
						: $mixchain;

	### SETTING DEVICES AS INPUTS (used by i.e. rec_setup)

	for my $dev (grep{
				$_ ne 'file' and $_ ne 'cooked' and $_ ne 'mixed'
			} keys %inputs ){
		$debug and print "dev: $dev\n";
		push  @input_chains, 
		join " ", "-a:" . (join ",", @{ $inputs{$dev} }),
			"-f:" .  $devices{$dev}->{input_format},
			"-i:" .  $devices{$dev}->{ecasound_id}, 
	}
	### SETTING LOOPS AS INPUTS (used by any @oids wanting processed signals)

	for my $n (@all_chains){
		next unless defined $inputs{cooked}->{$n} and @{ $inputs{cooked}->{$n} };
		push  @input_chains, 
		join " ", 
			"-a:" . (join ",", @{ $inputs{cooked}->{$n} }),
			"-i:loop,$n"
	}
	### SETTING MIXLOOPS AS INPUTS (used by any @oids wanting mixdown signals)

		if (defined $inputs{mixed} and @{ $inputs{mixed} }) {
			push  @input_chains, 
			join " ", 
				"-a:" . (join ",", @{ $inputs{mixed} }),
				"-i:$loopb";
			push @input_chains, "-a:$mixchain -i:$loopa";
			push @output_chains, "-a:$mixchain -o:$loopb";

		}

	
	##### SETTING FILES AS INPUTS (used by mon_setup)

	for my $file (keys %{ $inputs{file} } ) {
		$debug and print "monitor input file: $file\n";
		my $chain_ids = join ",",@{ $inputs{file}->{$file} };
		my ($n) = ($chain_ids =~ m/(\d+)/);
		$debug and print "track number: $n\n";
		push @input_chains, join ( " ",
					"-a:".$chain_ids,
			 		"-i:" .  join_path(this_wav_dir, 
					         $state_c{$n}->{targets}->{selected_version($n)}),
	   );
 	}
	##### SETTING FILES AS OUTPUTS (used by rec_file and mix)

	for my $file ( keys %{ $outputs{file} } ){
		my $n = $chain{$file};
		$debug and print "chain: $n, record output file: $file\n";
		$debug and print "file1: $state_c{$n}->{file}\n";
		my $chain_ids = join ",",@{ $outputs{file}->{$file} }; # expect one
		
		push @output_chains, join ( " ",
			 "-a:".$chain_ids,
			 "-f:".output_format($file),
			 "-o:". new_wav_name( $file ),
		 );
			 
	}

	#####  SETTING DEVICES AS OUTPUTS  (includes loop devices)
	for my $dev ( grep{!/file/ and !/loop/} keys %outputs ){
			push @output_chains, join " ",
				"-a:" . (join "," , @{ $outputs{$dev} }),
				"-f:" . $devices{$dev}->{output_format},
				"-o:". $devices{$dev}->{ecasound_id};

		
	}
	for my $dev ( grep{/loop/} keys %outputs ){
			push @output_chains, join " ",
				"-a:" . (join "," , @{ $outputs{$dev} }),
				"-o:". $dev; # in this case key is the same as device name

		
	}
		
	# $debug and print "\%state_c\n================\n", yaml_out(\%state_c);
	# $debug and print "\%state_t\n================\n",  yaml_out(\%state_t);
							
		
	## write general options
	
	my $ecs_file = "# ecasound chainsetup file\n\n\n";
	$ecs_file   .= "# general\n\n";
	$ecs_file   .= $ecasound_globals;
	$ecs_file   .= "\n\n\n# audio inputs\n\n";
	$ecs_file   .= join "\n", sort @input_chains;
	$ecs_file   .= "\n\n# post-input processing\n\n";
	$ecs_file   .= join "\n", sort map{ "-a:$_ $post_input{$_}"} keys %post_input;
	$ecs_file   .= "\n\n# pre-output processing\n\n";
	$ecs_file   .= join "\n", sort map{ "-a:$_ $pre_output{$_}"} keys %pre_output;
	$ecs_file   .= "\n\n# audio outputs\n\n";
	$ecs_file   .= join "\n", sort @output_chains, "\n";
	
	$debug and print "ECS:\n",$ecs_file;
	my $sf = join_path(&project_dir, $chain_setup_file);
	open ECS, ">$sf" or croak "can't open file $sf:  $!\n";
	print ECS $ecs_file;
	close ECS;
}
